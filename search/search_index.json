{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Data File Utils","text":"<p>A versatile Python toolkit comprising various scripts and utilities designed to streamline file manipulation tasks.</p>"},{"location":"#commands","title":"Commands","text":"<p>The following exported scripts are available:</p> <ul> <li>analyze-record-tuples</li> <li>archive-dir</li> <li>backup-dir</li> <li>backup-file</li> <li>compare-tab-files</li> <li>create-tmp-dir</li> <li>delete-old-files</li> <li>find-last-directory</li> <li>find-last-file</li> <li>jsonl2json</li> <li>profile-data-file</li> <li>tsv2json</li> <li>xlsx2tsv</li> </ul>"},{"location":"#references","title":"References","text":"<ul> <li>GitHub</li> <li>PYPI</li> </ul>"},{"location":"INSTALL/","title":"INSTALL","text":""},{"location":"INSTALL/#clone-project","title":"Clone project","text":"<p>You can <code>git clone</code> this project.</p> <pre><code>git clone https://github.com/jai-python3/data-file-utils.git\ncd data-file-utils\n</code></pre>"},{"location":"INSTALL/#local-pip-install","title":"Local pip install","text":"<p>You can optionally establish a Python virtual environment. Then you can run the <code>setup.py</code> script to build to project and then run <code>pip install</code> to install in your local Python virtual environment.</p> <pre><code>virtualenv -p python3 venv\nsource venv/bin/activate\npython setup.py sdist\npip install .\n</code></pre>"},{"location":"INSTALL/#uninstall","title":"Uninstall","text":"<p>You can uninstall like this:</p> <pre><code>source venv/bin/activate\npip uninstall data-file-utils\nmake clean\n</code></pre>"},{"location":"INSTALL/#developers","title":"Developers","text":"<p>If you modify the code in this package in your local virtual environment:</p> <pre><code>pip uninstall data-file-utils\nmake clean\npython setup.py sdist\npip install .\n</code></pre>"},{"location":"INSTALL/#publish-to-pypi","title":"Publish to PYPI","text":"<p>You want can publish the code in this package to the PYPI repository.</p>"},{"location":"INSTALL/#install-twine-and-setuptools","title":"Install twine and setuptools","text":"<p>Install <code>twine</code> and <code>setuptools</code>.</p> <pre><code>pip install twine setuptools\n</code></pre>"},{"location":"INSTALL/#build-the-distribution-package","title":"Build the Distribution Package","text":"<pre><code>python setup.py sdist bdist_wheel\n</code></pre>"},{"location":"INSTALL/#configure-your-pypirc","title":"Configure your ~/.pypirc:","text":"<pre><code>[pypi]\n  username = __token__\n  password = pypi-YOUR-TOKEN\n</code></pre>"},{"location":"INSTALL/#upload-your-package-to-pypi","title":"Upload Your Package to PyPI","text":"<pre><code>twine upload dist/*\n</code></pre>"},{"location":"INSTALL/#install-from-pypi","title":"Install from PYPI","text":"<p>Now you can install your package in your Python virtual environment</p> <pre><code>pip install data-file-utils\n</code></pre>"},{"location":"analyze_record_tuples/","title":"Analyze Record Tuples module","text":"<p>Compare two sorted review files line-by-line and column-by-column.</p>"},{"location":"analyze_record_tuples/#data_file_utils.analyze_record_tuples.analyze_files","title":"<code>analyze_files(file1_path, file2_path, outdir)</code>","text":"<p>Compare two tab-delimited files and store differences.</p> <p>Parameters:</p> Name Type Description Default <code>file1_path</code> <code>str</code> <p>The path to the first file to be compared.</p> required <code>file2_path</code> <code>str</code> <p>The path to the second file to be compared.</p> required <code>outdir</code> <code>str</code> <p>The output directory where logfile and default output file will be written.</p> required Source code in <code>data_file_utils/analyze_record_tuples.py</code> <pre><code>def analyze_files(\n        file1_path: str,\n        file2_path: str,\n        outdir: str,\n    ):\n    \"\"\"Compare two tab-delimited files and store differences.\n\n    Args:\n        file1_path (str): The path to the first file to be compared.\n        file2_path (str): The path to the second file to be compared.\n        outdir (str): The output directory where logfile and default output file will be written.\n    \"\"\"\n\n    header1, header_index_to_name_lookup1, header_name_to_index_lookup1, lookup1 = read_file(file1_path, outdir)\n    header2, header_index_to_name_lookup2, header_name_to_index_lookup2, lookup2 = read_file(file2_path, outdir)\n\n    # if header1 != header2:\n    #     print(\"Headers of the two files are different.\")\n    #     return\n\n    logging.info(\"Going to compare contents of the two files now\")\n\n    missing_in_file2_ctr = 0\n    missing_in_file2_list = []\n    found_in_file2_ctr = 0\n\n    for k1, line1 in lookup1.items():\n\n        if k1 not in lookup2:\n            logging.error(f\"Did not find record '{k1}' (at line '{line1}' in file1) in file2\")\n            missing_in_file2_ctr += 1\n            missing_in_file2_list.append([k1, line1])\n        else:\n            found_in_file2_ctr += 1\n\n\n\n    missing_in_file1_ctr = 0\n    missing_in_file1_list = []\n    found_in_file1_ctr = 0\n\n    for k2, line2 in lookup2.items():\n\n        if k2 not in lookup1:\n            logging.error(f\"Did not find record '{k2}' (at line '{line2}' in file2) in file2\")\n            missing_in_file1_ctr += 1\n            missing_in_file1_list.append([k2, line2])\n        else:\n            found_in_file1_ctr += 1\n\n\n    if missing_in_file1_ctr &gt; 0:\n        print(f\"Could not find '{missing_in_file1_ctr}' records in file 1 that were in file 2\")\n        print(\"See the log file for details\")\n        outfile = os.path.join(outdir, \"records_missing_from_file_1.txt\")\n        generate_missing_records_report(\n            outfile,\n            missing_in_file1_ctr,\n            missing_in_file1_list,\n            file1_path,\n            file2_path,\n            f\"The following '{missing_in_file1_ctr}' records were not found in file 1 '{file1_path}'\",\n            header1\n        )\n    else:\n        print(f\"Found all '{found_in_file1_ctr}' records in file 1 that were in file 2\")\n\n    if missing_in_file2_ctr &gt; 0:\n        print(f\"Could not find '{missing_in_file2_ctr}' records in file 2 that were in file 1\")\n        print(\"See the log file for details\")\n        outfile = os.path.join(outdir, \"records_missing_from_file_2.txt\")\n        generate_missing_records_report(\n            outfile,\n            missing_in_file2_ctr,\n            missing_in_file2_list,\n            file1_path,\n            file2_path,\n            f\"The following '{missing_in_file2_ctr}' records were not found in file 2 '{file2_path}'\",\n            header1\n        )\n    else:\n        print(f\"Found all '{found_in_file2_ctr}' records in file 2 that were in file 1\")\n</code></pre>"},{"location":"analyze_record_tuples/#data_file_utils.analyze_record_tuples.generate_duplicates_report","title":"<code>generate_duplicates_report(header, msg, duplicate_lookup, outfile)</code>","text":"<p>Generate a report of duplicate records.</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>List[str]</code> <p>List of filtered header strings.</p> required <code>msg</code> <code>str</code> <p>The message to be written to the output file.</p> required <code>duplicate_lookup</code> <code>Dict[str, List[str]]</code> <p>The lookup of duplicate records.</p> required <code>outfile</code> <code>str</code> <p>The path to the output file.</p> required Source code in <code>data_file_utils/analyze_record_tuples.py</code> <pre><code>def generate_duplicates_report(\n    header: List[str],\n    msg: str,\n    duplicate_lookup: Dict[str, List[str]],\n    # duplicate_list: List[List[str]],\n    outfile: str\n    ) -&gt; None:\n    \"\"\"Generate a report of duplicate records.\n\n    Args:\n        header (List[str]): List of filtered header strings.\n        msg (str): The message to be written to the output file.\n        duplicate_lookup (Dict[str, List[str]]): The lookup of duplicate records.\n        outfile (str): The path to the output file.\n    \"\"\"\n\n    with open(outfile, 'w') as of:\n        of.write(f\"## {msg}\\n\")\n        of.write(\"\\t\".join(header) + \"\\tLine Number\\n\")\n        for record, line_num_list in duplicate_lookup.items():\n            rec = record.replace(\"::\", \"\\t\")\n            lines = \", \".join(line_num_list)\n            of.write(f\"{rec}\\t{lines}\\n\")\n\n        # for parts in duplicate_list:\n        #     record = parts[0]\n        #     line_num = parts[1]\n        #     rec = record.replace(\"::\", \"\\t\")\n        #     of.write(f\"{rec}\\t{line_num}\\n\")\n\n    logging.info(f\"Wrote duplicate records report file '{outfile}'\")\n    print(f\"Wrote duplicate records report file '{outfile}'\")\n</code></pre>"},{"location":"analyze_record_tuples/#data_file_utils.analyze_record_tuples.generate_missing_records_report","title":"<code>generate_missing_records_report(outfile, missing_record_ctr, missing_record_list, file1_path, file2_path, msg, header)</code>","text":"<p>Generate a report of missing records.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str</code> <p>The path to the output file.</p> required <code>missing_record_ctr</code> <code>int</code> <p>The number of missing records.</p> required <code>missing_record_list</code> <code>List[Any]</code> <p>The list of missing records.</p> required <code>file1_path</code> <code>str</code> <p>The path to the first file.</p> required <code>file2_path</code> <code>str</code> <p>The path to the second file.</p> required <code>msg</code> <code>str</code> <p>The message to be written to the output file.</p> required <code>header</code> <code>List[str]</code> <p>The list of filtered header strings.</p> required Source code in <code>data_file_utils/analyze_record_tuples.py</code> <pre><code>def generate_missing_records_report(outfile: str, missing_record_ctr: int, missing_record_list: List[Any], file1_path: str, file2_path: str, msg: str, header: List[str]) -&gt; None:\n    \"\"\"Generate a report of missing records.\n\n    Args:\n        outfile (str): The path to the output file.\n        missing_record_ctr (int): The number of missing records.\n        missing_record_list (List[Any]): The list of missing records.\n        file1_path (str): The path to the first file.\n        file2_path (str): The path to the second file.\n        msg (str): The message to be written to the output file.\n        header (List[str]): The list of filtered header strings.\n    \"\"\"\n\n    with open(outfile, 'w') as of:\n        of.write(f\"## sorted review file 1: {file1_path}\\n\")\n        of.write(f\"## sorted review file 2: {file2_path}\\n\")\n        of.write(f\"## {msg}\\n\")\n        of.write(\"\\t\".join(header) + \"\\tLine Number\\n\")\n        for missing_list in missing_record_list:\n            missing_record = missing_list[0]\n            line_num = missing_list[1]\n            rec = missing_record.replace(\"::\", \"\\t\")\n            of.write(f\"{rec}\\t{line_num}\\n\")\n\n\n    logging.info(f\"Wrote missing records report file '{outfile}'\")\n    print(f\"Wrote missing records report file '{outfile}'\")\n</code></pre>"},{"location":"analyze_record_tuples/#data_file_utils.analyze_record_tuples.get_column_number_to_column_letters_lookup","title":"<code>get_column_number_to_column_letters_lookup(max_column_number=MAX_COLUMN_COUNT)</code>","text":"<p>Generate a lookup of column numbers to column letters.</p> <p>Parameters:</p> Name Type Description Default <code>max_column_number</code> <code>int</code> <p>The maximum column number. Defaults to MAX_COLUMN_COUNT.</p> <code>MAX_COLUMN_COUNT</code> <p>Returns:</p> Type Description <code>Dict[int, str]</code> <p>Dict[int, str]: A lookup of column numbers to column letters.</p> Source code in <code>data_file_utils/analyze_record_tuples.py</code> <pre><code>def get_column_number_to_column_letters_lookup(max_column_number: int = MAX_COLUMN_COUNT) -&gt; Dict[int, str]:\n    \"\"\"Generate a lookup of column numbers to column letters.\n\n    Args:\n        max_column_number (int, optional): The maximum column number. Defaults to MAX_COLUMN_COUNT.\n\n    Returns:\n        Dict[int, str]: A lookup of column numbers to column letters.\n    \"\"\"\n    column_numbers = [x for x in range(max_column_number)]\n    lookup = {}\n    for column_number in column_numbers:\n        column_letter = xlsxwriter.utility.xl_col_to_name(column_number)\n        column_number += 1\n        logging.debug(f\"Converted column number '{column_number}' to column letter '{column_letter}'\")\n        lookup[column_number] = column_letter\n    return lookup\n</code></pre>"},{"location":"analyze_record_tuples/#data_file_utils.analyze_record_tuples.get_ignore_columns_lookup","title":"<code>get_ignore_columns_lookup(ignore_columns_str)</code>","text":"<p>Load a lookup of columns to be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>ignore_columns_str</code> <code>str</code> <p>The comma-separated list of columns to be ignored.</p> required <p>Returns:</p> Type Description <code>Dict[str, bool]</code> <p>Dict[str, bool]: The lookup of columns to be ignored.</p> Source code in <code>data_file_utils/analyze_record_tuples.py</code> <pre><code>def get_ignore_columns_lookup(ignore_columns_str: str) -&gt; Dict[str, bool]:\n    \"\"\"Load a lookup of columns to be ignored.\n\n    Args:\n        ignore_columns_str (str): The comma-separated list of columns to be ignored.\n\n    Returns:\n        Dict[str, bool]: The lookup of columns to be ignored.\n    \"\"\"\n    ignore_columns_lookup = {}\n    logging.info(f\"Will ignore columns: {ignore_columns_str}\")\n    columns = ignore_columns_str.split(\",\")\n    for column in columns:\n        ignore_columns_lookup[column.strip()] = True\n    return ignore_columns_lookup\n</code></pre>"},{"location":"analyze_record_tuples/#data_file_utils.analyze_record_tuples.main","title":"<code>main(logfile, outdir, outfile, sorted_review_file_1, sorted_review_file_2, verbose)</code>","text":"<p>Compare two sorted review files line-by-line and column-by-column.</p> <p>Parameters:</p> Name Type Description Default <code>logfile</code> <code>str</code> <p>The log file.</p> required <code>outdir</code> <code>str</code> <p>The output directory where logfile and default output file will be written.</p> required <code>outfile</code> <code>str</code> <p>The output file to which differences will be written to.</p> required <code>sorted_review_file_1</code> <code>str</code> <p>The first sorted review file (.tsv).</p> required <code>sorted_review_file_2</code> <code>str</code> <p>The second sorted review file (.tsv).</p> required <code>verbose</code> <code>bool</code> <p>Will print more info to STDOUT.</p> required Source code in <code>data_file_utils/analyze_record_tuples.py</code> <pre><code>@click.command()\n@click.option('--logfile', help=\"Optional: The log file\")\n@click.option('--outdir', help=\"Optional: The output directory where logfile and default output file will be written - default is '{DEFAULT_OUTDIR}'\")\n@click.option('--outfile', help=\"Optional: The output file to which differences will be written to - default is '{DEFAULT_OUTFILE}'\")\n@click.option('--sorted_review_file_1', help=\"Required: The first sorted review file (.tsv)\")\n@click.option('--sorted_review_file_2', help=\"Required: The second sorted review file (.tsv)\")\n@click.option('--verbose', is_flag=True, help=f\"Will print more info to STDOUT - default is '{DEFAULT_VERBOSE}'.\", callback=validate_verbose)\ndef main(logfile: Optional[str], outdir: Optional[str], outfile: Optional[str], sorted_review_file_1: str, sorted_review_file_2: str, verbose: Optional[bool]):\n    \"\"\"Compare two sorted review files line-by-line and column-by-column.\n\n    Args:\n        logfile (str): The log file.\n        outdir (str): The output directory where logfile and default output file will be written.\n        outfile (str): The output file to which differences will be written to.\n        sorted_review_file_1 (str): The first sorted review file (.tsv).\n        sorted_review_file_2 (str): The second sorted review file (.tsv).\n        verbose (bool): Will print more info to STDOUT.\n    \"\"\"\n\n    error_ctr = 0\n\n    if sorted_review_file_1 is None:\n        error_console.print(\"--sorted_review_file_1 was not specified\")\n        error_ctr += 1\n\n    if sorted_review_file_2 is None:\n        error_console.print(\"--sorted_review_file_2 was not specified\")\n        error_ctr += 1\n\n    if error_ctr &gt; 0:\n        error_console.print(\"Required command-line arguments were not provided\")\n        click.echo(click.get_current_context().get_help())\n        sys.exit(1)\n\n    check_infile_status(sorted_review_file_1)\n    check_infile_status(sorted_review_file_2)\n\n    if outdir is None:\n        outdir = DEFAULT_OUTDIR\n        console.print(f\"[yellow]--outdir was not specified and therefore was set to '{outdir}'[/]\")\n\n    if not os.path.exists(outdir):\n        pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)\n        console.print(f\"[yellow]Created output directory '{outdir}'[/]\")\n\n    if logfile is None:\n        logfile = os.path.join(\n            outdir,\n            os.path.splitext(os.path.basename(__file__))[0] + '.log'\n        )\n        console.print(f\"[yellow]--logfile was not specified and therefore was set to '{logfile}'[/]\")\n\n    if outfile is None:\n        outfile = DEFAULT_OUTFILE\n        console.print(f\"[yellow]--outfile was not specified and therefore was set to '{outfile}'[/]\")\n\n\n    logging.basicConfig(\n        filename=logfile,\n        format=DEFAULT_LOGGING_FORMAT,\n        level=DEFAULT_LOGGING_LEVEL,\n    )\n\n    analyze_files(sorted_review_file_1, sorted_review_file_2, outdir)\n\n    if verbose:\n        console.print(f\"The log file is '{logfile}'\")\n        console.print(f\"[bold green]Execution of '{os.path.abspath(__file__)}' completed[/]\")\n</code></pre>"},{"location":"analyze_record_tuples/#data_file_utils.analyze_record_tuples.read_file","title":"<code>read_file(file_path, outdir)</code>","text":"<p>Read a tab-delimited file and return its content as a list of lists.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file to be read.</p> required <code>outdir</code> <code>str</code> <p>The output directory where logfile and default output file will be written.</p> required Source code in <code>data_file_utils/analyze_record_tuples.py</code> <pre><code>def read_file(file_path, outdir):\n    \"\"\"Read a tab-delimited file and return its content as a list of lists.\n\n    Args:\n        file_path (str): The path to the file to be read.\n        outdir (str): The output directory where logfile and default output file will be written.\n    \"\"\"\n    logging.info(f\"Going to read file '{file_path}'\")\n    with open(file_path, 'r', encoding=\"latin-1\") as file:\n        lines = file.readlines()\n    header = lines[HEADER_LINE].strip().split('\\t')\n    header_index_to_name_lookup = {}\n    header_name_to_index_lookup = {}\n    filtered_header = []\n    for i, h in enumerate(header, start=1):\n        if i not in TUPLE_COLUMNS:\n            logging.info(f\"Ignore column number '{i}' with name\")\n            continue\n        true_header_index = i - 1\n        h = h.strip()\n        header_index_to_name_lookup[true_header_index] = h\n        header_name_to_index_lookup[h] = true_header_index\n        filtered_header.append(h)\n\n    data = []\n    lookup = {}\n    duplicate_lookup = {}\n    duplicate_list = []\n    duplicate_ctr = 0\n\n    line_num = RECORDS_START_LINE\n    for line in lines[RECORDS_START_LINE:]:\n        fields = line.strip().split('\\t')\n        record = []\n        for i, field in enumerate(fields, start=1):\n            if i not in TUPLE_COLUMNS:\n                continue\n            true_header_index = i - 1\n            field = field.strip()\n            if true_header_index in header_index_to_name_lookup and header_index_to_name_lookup[true_header_index].lower() == \"mutation\":\n                if field.endswith(\"()\"):\n                    field = field.rstrip(\"()\").strip()\n\n            record.append(field)\n        line_num += 1\n        rec_key = \"::\".join(record)\n        if rec_key in lookup:\n            duplicate_ctr += 1\n            prev_line = lookup[rec_key]\n            # duplicate_list.append([rec_key, f\"{line_num}, {prev_line}\"])\n            if rec_key not in duplicate_lookup:\n                duplicate_lookup[rec_key] = []\n                duplicate_lookup[rec_key].append(f\"{prev_line}\")\n            duplicate_lookup[rec_key].append(f\"{line_num}\")\n\n            logging.error(f\"Record '{rec_key}' encountered at line '{line_num}' and previous line '{prev_line}' in file '{file_path}' - so will not include this in the lookup\")\n            continue\n            # raise Exception(f\"Record '{rec_key}' encountered at line '{line_num}' and previous line '{prev_line}'\")\n        # data.append(record)\n        lookup[rec_key] = line_num\n\n    if duplicate_ctr &gt; 0:\n        outfile = os.path.join(outdir, f\"duplicate_records_{os.path.basename(file_path)}.report.txt\")\n        generate_duplicates_report(\n            filtered_header,\n            f\"Found '{duplicate_ctr}' duplicate records in file '{file_path}'\",\n            duplicate_lookup,\n            outfile\n        )\n    else:\n        logging.info(f\"Did not encounter any duplicate records in file '{file_path}'\")\n\n    return filtered_header, header_index_to_name_lookup, header_name_to_index_lookup, lookup\n</code></pre>"},{"location":"analyze_record_tuples/#data_file_utils.analyze_record_tuples.validate_verbose","title":"<code>validate_verbose(ctx, param, value)</code>","text":"<p>Validate the --verbose command-line option.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>context</code> <p>The context.</p> required <code>param</code> <code>str</code> <p>The parameter name.</p> required <code>value</code> <code>bool</code> <p>The boolean value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>The boolean value.</p> Source code in <code>data_file_utils/analyze_record_tuples.py</code> <pre><code>def validate_verbose(ctx, param, value):\n    \"\"\"Validate the --verbose command-line option.\n\n    Args:\n        ctx (context): The context.\n        param (str): The parameter name.\n        value (bool): The boolean value.\n\n    Returns:\n        bool: The boolean value.\n    \"\"\"\n    if value is None:\n        click.secho(\"--verbose was not specified and therefore was set to 'True'\", fg='yellow')\n        return DEFAULT_VERBOSE\n    return value\n</code></pre>"},{"location":"archive_dir/","title":"Archive Dir module","text":"<p>Archive a directory in-place.</p>"},{"location":"archive_dir/#data_file_utils.archive_dir.archive_directory","title":"<code>archive_directory(directory_path)</code>","text":"<p>Archive a directory in-place.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>str</code> <p>the directory to be archived in-place</p> required Source code in <code>data_file_utils/archive_dir.py</code> <pre><code>def archive_directory(directory_path: str) -&gt; None:\n    \"\"\"Archive a directory in-place.\n\n    Args:\n        directory_path (str): the directory to be archived in-place\n    \"\"\"\n    # Get the base name of the target directory\n    current_dir = os.getcwd()\n    dirname = os.path.dirname(directory_path)\n    os.chdir(dirname)\n\n    base_name = os.path.basename(directory_path)\n\n    # Get the current timestamp\n    timestamp = datetime.now().strftime(\"%Y-%m-%d-%H%M%S\")\n\n    # Create the target filename with .tgz extension\n    target_filename = f\"{base_name}_{timestamp}.tgz\"\n\n    # Build the tar command\n    tar_command = [\"tar\", \"zcvf\", target_filename, base_name]\n\n    try:\n        # Execute the tar command using subprocess\n        subprocess.run(tar_command, check=True)\n        print(f\"Directory '{directory_path}' successfully archived to '{target_filename}'\")\n    except subprocess.CalledProcessError as e:\n        print(f\"Error: {e}\")\n\n    os.chdir(current_dir)\n</code></pre>"},{"location":"archive_dir/#data_file_utils.archive_dir.main","title":"<code>main(indir)</code>","text":"<p>Archive a directory in-place.</p> <p>Parameters:</p> Name Type Description Default <code>indir</code> <code>str</code> <p>the directory to be archived in-place</p> required Source code in <code>data_file_utils/archive_dir.py</code> <pre><code>@click.command()\n@click.argument('indir', type=str, required=True)\ndef main(indir: str):\n    \"\"\"Archive a directory in-place.\n\n    Args:\n        indir (str): the directory to be archived in-place\n    \"\"\"\n\n    error_ctr = 0\n\n    if indir is None:\n        error_console.print(f\"Usage: {os.path.basename(__file__)} dir\")\n        error_ctr += 1\n\n    if error_ctr &gt; 0:\n        sys.exit(1)\n\n    check_indir_status(indir)\n\n    archive_directory(indir)\n</code></pre>"},{"location":"backup_dir/","title":"Backup Dir module","text":"<p>Backup a file.</p>"},{"location":"backup_dir/#data_file_utils.backup_dir.main","title":"<code>main(indir)</code>","text":"<p>Backup a directory in-place.</p> <p>Parameters:</p> Name Type Description Default <code>indir</code> <code>str</code> <p>The directory to be backed up in-place.</p> required Source code in <code>data_file_utils/backup_dir.py</code> <pre><code>@click.command()\n@click.argument('indir', type=str, required=True)\ndef main(indir: str):\n    \"\"\"Backup a directory in-place.\n\n    Args:\n        indir (str): The directory to be backed up in-place.\n    \"\"\"\n\n    error_ctr = 0\n\n    if indir is None:\n        error_console.print(f\"Usage: {os.path.basename(__file__)} dir\")\n        error_ctr += 1\n\n    if error_ctr &gt; 0:\n        sys.exit(1)\n\n    check_indir_status(indir)\n\n    bakdir = os.path.join(indir + f\".{DEFAULT_TIMESTAMP}.bak\")\n\n    shutil.copytree(indir, bakdir)\n    print(f\"Backed-up '{indir}' to '{bakdir}'\")\n</code></pre>"},{"location":"backup_file/","title":"Backup File module","text":"<p>Backup a file.</p>"},{"location":"backup_file/#data_file_utils.backup_file.main","title":"<code>main(infile)</code>","text":"<p>Backup a file in-place.</p> <p>Parameters:</p> Name Type Description Default <code>infile</code> <code>str</code> <p>The file to be backed up in-place.</p> required Source code in <code>data_file_utils/backup_file.py</code> <pre><code>@click.command()\n@click.argument('infile', type=str, required=True)\ndef main(infile: str):\n    \"\"\"Backup a file in-place.\n\n    Args:\n        infile (str): The file to be backed up in-place.\n    \"\"\"\n\n    error_ctr = 0\n\n    if infile is None:\n        error_console.print(f\"Usage: {os.path.basename(__file__)} infile\")\n        error_ctr += 1\n\n    if error_ctr &gt; 0:\n        sys.exit(1)\n\n    check_infile_status(infile)\n\n    dirname = os.path.dirname(infile)\n    bakfile = os.path.join(\n        dirname,\n        os.path.basename(infile) + f\".{DEFAULT_TIMESTAMP}.bak\"\n    )\n\n    shutil.copyfile(infile, bakfile)\n    print(f\"Backed-up '{infile}' to '{bakfile}'\")\n</code></pre>"},{"location":"compare_tab_files/","title":"Compare Tab Files module","text":"<p>Compare two sorted review files line-by-line and column-by-column.</p>"},{"location":"compare_tab_files/#data_file_utils.compare_tab_files.compare_files","title":"<code>compare_files(file1_path, file2_path, ignore_columns, ignore_columns_str)</code>","text":"<p>Compare two tab-delimited files and store differences.</p> <p>Parameters:</p> Name Type Description Default <code>file1_path</code> <code>str</code> <p>The path to the first file to be compared.</p> required <code>file2_path</code> <code>str</code> <p>The path to the second file to be compared.</p> required <code>ignore_columns</code> <code>bool</code> <p>Whether to ignore columns.</p> required <code>ignore_columns_str</code> <code>Optional[str]</code> <p>The comma-separated list of columns to be ignored.</p> required Source code in <code>data_file_utils/compare_tab_files.py</code> <pre><code>def compare_files(file1_path: str, file2_path: str, ignore_columns: bool, ignore_columns_str: Optional[str]):\n    \"\"\"Compare two tab-delimited files and store differences.\n\n    Args:\n        file1_path (str): The path to the first file to be compared.\n        file2_path (str): The path to the second file to be compared.\n        ignore_columns (bool): Whether to ignore columns.\n        ignore_columns_str (Optional[str]): The comma-separated list of columns to be ignored.\n    \"\"\"\n    header1, header_index_to_name_lookup1, header_name_to_index_lookup1, data1 = read_file(file1_path)\n    header2, header_index_to_name_lookup2, header_name_to_index_lookup2, data2 = read_file(file2_path)\n\n    if ignore_columns:\n        ignore_columns_lookup = get_ignore_columns_lookup(ignore_columns_str)\n\n    # if header1 != header2:\n    #     print(\"Headers of the two files are different.\")\n    #     return\n\n    logging.info(\"Going to compare contents of the two files now\")\n\n    max_rows = max(len(data1), len(data2))\n    differences = []\n    max_max_columns = 0\n\n    for i in range(1, max_rows + 1):\n        if i &lt;= len(data1):\n            row1 = data1[i - 1]\n        else:\n            row1 = [\"\"] * len(header1)\n\n        if i &lt;= len(data2):\n            row2 = data2[i - 1]\n        else:\n            row2 = [\"\"] * len(header2)\n\n        max_columns = max(len(row1), len(row2))\n        if max_columns &gt; max_max_columns:\n            max_max_columns = max_columns\n\n        # max_columns = 59\n\n        for j in range(0, max_columns):\n\n            cell1 = row1[j] if j &lt; len(row1) else \"\"\n            cell2 = row2[j] if j &lt; len(row2) else \"\"\n\n            if cell1 != cell2:\n                if ignore_columns and j in header_index_to_name_lookup1 and header_index_to_name_lookup1[j] in ignore_columns_lookup:\n                    logging.info(f\"Found differences in cell 1 '{cell1}' and cell 2 '{cell2}' but will ignore\")\n                    continue\n                # logging.info(f\"i '{i}' j '{j}' max_columns '{max_columns}' max_rows '{max_rows}' cell1 '{cell1}' cell2 '{cell2}'\")\n                differences.append((i, header1[j] if j &lt; len(header1) else header2[j], j + 1, cell1, cell2))\n\n    global MAX_COLUMN_COUNT\n    MAX_COLUMN_COUNT = max_max_columns\n    return differences\n</code></pre>"},{"location":"compare_tab_files/#data_file_utils.compare_tab_files.get_column_number_to_column_letters_lookup","title":"<code>get_column_number_to_column_letters_lookup(max_column_number=MAX_COLUMN_COUNT)</code>","text":"<p>Get a lookup of column numbers to column letters.</p> <p>Parameters:</p> Name Type Description Default <code>max_column_number</code> <code>int</code> <p>The maximum number of columns. Defaults to MAX_COLUMN_COUNT.</p> <code>MAX_COLUMN_COUNT</code> <p>Returns:</p> Type Description <code>Dict[int, str]</code> <p>Dict[int, str]: The lookup of column numbers to column letters.</p> Source code in <code>data_file_utils/compare_tab_files.py</code> <pre><code>def get_column_number_to_column_letters_lookup(max_column_number: int = MAX_COLUMN_COUNT) -&gt; Dict[int, str]:\n    \"\"\"Get a lookup of column numbers to column letters.\n\n    Args:\n        max_column_number (int, optional): The maximum number of columns. Defaults to MAX_COLUMN_COUNT.\n\n    Returns:\n        Dict[int, str]: The lookup of column numbers to column letters.\n    \"\"\"\n    column_numbers = [x for x in range(max_column_number)]\n    lookup = {}\n    for column_number in column_numbers:\n        column_letter = xlsxwriter.utility.xl_col_to_name(column_number)\n        column_number += 1\n        logging.debug(f\"Converted column number '{column_number}' to column letter '{column_letter}'\")\n        lookup[column_number] = column_letter\n    return lookup\n</code></pre>"},{"location":"compare_tab_files/#data_file_utils.compare_tab_files.main","title":"<code>main(ignore_columns, ignore_columns_str, logfile, outdir, outfile, tab_file_1, tab_file_2, verbose)</code>","text":"<p>Compare two sorted review files line-by-line and column-by-column.</p> Source code in <code>data_file_utils/compare_tab_files.py</code> <pre><code>@click.command()\n@click.option('--ignore_columns', is_flag=True, help=f\"Optional: Ignore columns specified in --ignore_columns_str - default is '{DEFAULT_IGNORE_COLUMNS}'\")\n@click.option('--ignore_columns_str', help=\"Optional: comma-separated list of column headers wrapped in quotes\")\n@click.option('--logfile', help=\"Optional: The log file\")\n@click.option('--outdir', help=f\"Optional: The output directory where logfile and default output file will be written - default is '{DEFAULT_OUTDIR}'\")\n@click.option('--outfile', help=f\"Optional: The output file to which differences will be written to - default is '{DEFAULT_OUTFILE}'\")\n@click.option('--tab_file_1', help=\"Required: The first sorted review file (.tsv)\")\n@click.option('--tab_file_2', help=\"Required: The second sorted review file (.tsv)\")\n@click.option('--verbose', is_flag=True, help=f\"Will print more info to STDOUT - default is '{DEFAULT_VERBOSE}'.\", callback=validate_verbose)\ndef main(ignore_columns: Optional[bool], ignore_columns_str: Optional[str], logfile: Optional[str], outdir: Optional[str], outfile: Optional[str], tab_file_1: str, tab_file_2: str, verbose: Optional[bool]):\n    \"\"\"Compare two sorted review files line-by-line and column-by-column.\"\"\"\n\n    error_ctr = 0\n\n    if tab_file_1 is None:\n        error_console.print(\"--tab_file_1 was not specified\")\n        error_ctr += 1\n\n    if tab_file_2 is None:\n        error_console.print(\"--tab_file_2 was not specified\")\n        error_ctr += 1\n\n    if error_ctr &gt; 0:\n        error_console.print(\"Required command-line arguments were not provided\")\n        sys.exit(1)\n\n    check_infile_status(tab_file_1)\n    check_infile_status(tab_file_2)\n\n    if ignore_columns is None:\n        ignore_columns = DEFAULT_IGNORE_COLUMNS\n        console.print(f\"[yellow]--ignore_columns was not specified and therefore was set to '{ignore_columns}'[/]\")\n\n\n    if outdir is None:\n        outdir = DEFAULT_OUTDIR\n        console.print(f\"[yellow]--outdir was not specified and therefore was set to '{outdir}'[/]\")\n\n    if not os.path.exists(outdir):\n        pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)\n        console.print(f\"[yellow]Created output directory '{outdir}'[/]\")\n\n    if logfile is None:\n        logfile = os.path.join(\n            outdir,\n            os.path.splitext(os.path.basename(__file__))[0] + '.log'\n        )\n        console.print(f\"[yellow]--logfile was not specified and therefore was set to '{logfile}'[/]\")\n\n    if outfile is None:\n        outfile = DEFAULT_OUTFILE\n        console.print(f\"[yellow]--outfile was not specified and therefore was set to '{outfile}'[/]\")\n\n    if ignore_columns:\n        if ignore_columns_str is None:\n            console.print(f\"[bold red]--ignore_columns was specified but --ignore_columns_str was not specified[/]\")\n            sys.exit(-1)\n\n    logging.basicConfig(\n        filename=logfile,\n        format=DEFAULT_LOGGING_FORMAT,\n        level=DEFAULT_LOGGING_LEVEL,\n    )\n\n    differences = compare_files(\n        tab_file_1,\n        tab_file_2,\n        ignore_columns,\n        ignore_columns_str\n    )\n\n    if differences:\n        print(f\"[bold red]{len(differences)} differences found[/]\")\n        logging.info(f\"{len(differences)} differences found\")\n\n        lookup = get_column_number_to_column_letters_lookup(MAX_COLUMN_COUNT)\n\n        with open(outfile, 'w') as of:\n            of.write(f\"## method-created: {os.path.abspath(__file__)}\\n\")\n            of.write(f\"## date-created: {str(datetime.today().strftime('%Y-%m-%d-%H%M%S'))}\\n\")\n            of.write(f\"## created-by: {os.environ.get('USER')}\\n\")\n            of.write(f\"## tab-delimited file 1: {tab_file_1}\\n\")\n            of.write(f\"## tab-delimited file 2: {tab_file_2}\\n\")\n            of.write(f\"## logfile: {logfile}\\n\")\n\n            of.write(\"Line #\\tColumn Name\\tColumn #\\tColumn Letter\\tValue in File 1\\tValue in File 2\\n\")\n            for diff in differences:\n                excel_column_letters = lookup[diff[2]]\n                of.write(f\"{diff[0]}\\t{diff[1]}\\t{diff[2]}\\t{excel_column_letters}\\t{diff[3]}\\t{diff[4]}\\n\")\n\n        logging.info(f\"Wrote differences to output file '{outfile}'\")\n        if verbose:\n            print(f\"Wrote differences to output file '{outfile}'\")\n\n    else:\n        print(\"[green]No differences found.[/]\")\n        logging.info(\"No differences found.\")\n\n    print(f\"The log file is '{logfile}'\")\n    console.print(f\"[bold green]Execution of '{os.path.abspath(__file__)}' completed[/]\")\n</code></pre>"},{"location":"compare_tab_files/#data_file_utils.compare_tab_files.read_file","title":"<code>read_file(file_path)</code>","text":"<p>Read a tab-delimited file and return its content as a list of lists.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file to be read.</p> required Source code in <code>data_file_utils/compare_tab_files.py</code> <pre><code>def read_file(file_path: str):\n    \"\"\"Read a tab-delimited file and return its content as a list of lists.\n\n    Args:\n        file_path (str): The path to the file to be read.\n    \"\"\"\n    logging.info(f\"Going to read file '{file_path}'\")\n    with open(file_path, 'r', encoding=\"latin-1\") as file:\n        lines = file.readlines()\n    header = lines[HEADER_LINE].strip().split('\\t')\n    header_index_to_name_lookup = {}\n    header_name_to_index_lookup = {}\n    for i, h in enumerate(header):\n        header_index_to_name_lookup[i] = h\n        header_name_to_index_lookup[h] = i\n    data = [line.strip().split('\\t') for line in lines[RECORDS_START_LINE:]]\n    return header, header_index_to_name_lookup, header_name_to_index_lookup, data\n</code></pre>"},{"location":"compare_tab_files/#data_file_utils.compare_tab_files.validate_verbose","title":"<code>validate_verbose(ctx, param, value)</code>","text":"<p>Validate the validate option.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The click context.</p> required <code>param</code> <code>str</code> <p>The parameter.</p> required <code>value</code> <code>bool</code> <p>The value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>The value.</p> Source code in <code>data_file_utils/compare_tab_files.py</code> <pre><code>def validate_verbose(ctx, param, value):\n    \"\"\"Validate the validate option.\n\n    Args:\n        ctx (Context): The click context.\n        param (str): The parameter.\n        value (bool): The value.\n\n    Returns:\n        bool: The value.\n    \"\"\"\n\n    if value is None:\n        click.secho(\"--verbose was not specified and therefore was set to 'True'\", fg='yellow')\n        return DEFAULT_VERBOSE\n    return value\n</code></pre>"},{"location":"console_helper/","title":"Console Helper module","text":"<p>Module for console helper functions.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If msg is not defined</p>"},{"location":"console_helper/#data_file_utils.console_helper.print_green","title":"<code>print_green(msg=None)</code>","text":"<p>Print a message in green.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to be printed in red. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If msg is not defined</p> Source code in <code>data_file_utils/console_helper.py</code> <pre><code>def print_green(msg: str = None) -&gt; None:\n    \"\"\"Print a message in green.\n\n    Args:\n        msg (str, optional): The message to be printed in red. Defaults to None.\n\n    Raises:\n        Exception: If msg is not defined\n    \"\"\"\n    if msg is None or msg == \"\":\n        raise Exception(\"msg was not defined\")\n\n    console.print(f\"[bold green]{msg}[/]\")\n</code></pre>"},{"location":"console_helper/#data_file_utils.console_helper.print_red","title":"<code>print_red(msg=None)</code>","text":"<p>Print a message in red.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to be printed in red. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If msg is not defined</p> Source code in <code>data_file_utils/console_helper.py</code> <pre><code>def print_red(msg: str = None) -&gt; None:\n    \"\"\"Print a message in red.\n\n    Args:\n        msg (str, optional): The message to be printed in red. Defaults to None.\n\n    Raises:\n        Exception: If msg is not defined\n    \"\"\"\n    if msg is None or msg == \"\":\n        raise Exception(\"msg was not defined\")\n    error_console.print(msg)\n</code></pre>"},{"location":"console_helper/#data_file_utils.console_helper.print_yellow","title":"<code>print_yellow(msg=None)</code>","text":"<p>Print a message in yellow.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to be printed in red. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If msg is not defined</p> Source code in <code>data_file_utils/console_helper.py</code> <pre><code>def print_yellow(msg: str = None) -&gt; None:\n    \"\"\"Print a message in yellow.\n\n    Args:\n        msg (str, optional): The message to be printed in red. Defaults to None.\n\n    Raises:\n        Exception: If msg is not defined\n    \"\"\"\n    if msg is None or msg == \"\":\n        raise Exception(\"msg was not defined\")\n\n    console.print(f\"[bold yellow]{msg}[/]\")\n</code></pre>"},{"location":"create_tmp_dir/","title":"Create Tmp Dir module","text":"<p>Create a temporary directory.</p>"},{"location":"create_tmp_dir/#data_file_utils.create_tmp_dir.main","title":"<code>main()</code>","text":"<p>Create a temporary directory.</p> Source code in <code>data_file_utils/create_tmp_dir.py</code> <pre><code>def main():\n    \"\"\"Create a temporary directory.\"\"\"\n\n    root = input(\"Enter the root directory: [/tmp]: \")\n    if root == \"\":\n        root = \"/tmp\"\n    root = root.strip()\n\n    userdir = input(f\"Enter the user directory: [{DEFAULT_USERNAME}]: \")\n    if userdir is None or userdir == \"\":\n        userdir = DEFAULT_USERNAME\n    if userdir is not None:\n        userdir = userdir.strip()\n\n    purpose = None\n    while purpose is None or purpose == \"\":\n        purpose = input(\"Enter the purpose of the directory: \")\n        purpose = purpose.strip().replace(\" \", \"_\")\n\n    outdir = os.path.join(root, userdir, purpose, DEFAULT_TIMESTAMP)\n\n    if not os.path.exists(outdir):\n        pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)\n        print(f\"Created output directory '{outdir}'\")\n</code></pre>"},{"location":"delete_users_files/","title":"Delete Users Files module","text":"<p>Delete user's old files and directories.</p>"},{"location":"delete_users_files/#data_file_utils.delete_users_files.delete_files_created_by_user","title":"<code>delete_files_created_by_user(logfile, outfile=DEFAULT_OUTDIR, directory=DEFAULT_INDIR, username=DEFAULT_USERNAME, days_ago=DEFAULT_DAYS_OLD, no_test=DEFAULT_NO_TEST_MODE, verbose=DEFAULT_VERBOSE)</code>","text":"<p>Delete files and directories that belong to the specified user and were created more than the specified number of days ago.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>The directory to check for old files belonging to the specified user. Defaults to DEFAULT_INDIR.</p> <code>DEFAULT_INDIR</code> <code>username</code> <code>str</code> <p>The user that owns old files and directories to be deleted. Defaults to DEFAULT_USERNAME.</p> <code>DEFAULT_USERNAME</code> <code>days_ago</code> <code>int</code> <p>The minimum number of days ago that the files or directories were created. Defaults to DEFAULT_DAYS_OLD.</p> <code>DEFAULT_DAYS_OLD</code> <code>no_test</code> <code>bool</code> <p>If True, will not delete files and directories.  If False, will delete files and directories. Defaults to DEFAULT_NO_TEST_MODE.</p> <code>DEFAULT_NO_TEST_MODE</code> <code>verbose</code> <code>bool</code> <p>If True, will print more info to STDOUT.  If False, will not print more info to STDOUT. Defaults to DEFAULT_VERBOSE.</p> <code>DEFAULT_VERBOSE</code> Source code in <code>data_file_utils/delete_users_files.py</code> <pre><code>def delete_files_created_by_user(\n        logfile: str,\n        outfile: str = DEFAULT_OUTDIR,\n        directory: str = DEFAULT_INDIR,\n        username: str = DEFAULT_USERNAME,\n        days_ago: int = DEFAULT_DAYS_OLD,\n        no_test: bool = DEFAULT_NO_TEST_MODE,\n        verbose: bool = DEFAULT_VERBOSE):\n    \"\"\"Delete files and directories that belong to the specified user and were created more than the specified number of days ago.\n\n    Args:\n        directory (str, optional): The directory to check for old files belonging to the specified user. Defaults to DEFAULT_INDIR.\n        username (str, optional): The user that owns old files and directories to be deleted. Defaults to DEFAULT_USERNAME.\n        days_ago (int, optional): The minimum number of days ago that the files or directories were created. Defaults to DEFAULT_DAYS_OLD.\n        no_test (bool, optional): If True, will not delete files and directories.  If False, will delete files and directories. Defaults to DEFAULT_NO_TEST_MODE.\n        verbose (bool, optional): If True, will print more info to STDOUT.  If False, will not print more info to STDOUT. Defaults to DEFAULT_VERBOSE.\n    \"\"\"\n    if verbose:\n        print(f\"Will attempt to identify and delete all files and subdirectories that belong to username '{username}' that are older than '{days_ago}' days old\")\n    logging.info(f\"Will attempt to identify and delete all files and subdirectories that belong to username '{username}' that are older than '{days_ago}' days old\")\n\n    cutoff_time = datetime.now() - timedelta(days=days_ago)\n\n    file_ctr = 0\n    file_deleted_ctr = 0\n    dir_ctr = 0\n    dir_deleted_ctr = 0\n    something_else_ctr = 0\n    recent_file_ctr = 0\n    recent_dir_ctr = 0\n    recent_something_else_ctr = 0\n    other_user_ctr = 0\n\n    delete_files_list = []\n    delete_dirs_list = []\n\n    for root, dirs, files in os.walk(directory):\n        for name in files + dirs:\n            path = os.path.join(root, name)\n            stat_info = os.stat(path)\n\n            user_info = pwd.getpwuid(stat_info.st_uid)\n\n            if user_info.pw_name != username:\n                other_user_ctr += 1\n                continue\n\n            if os.path.isfile(path):\n                file_ctr += 1\n            elif os.path.isdir(path):\n                dir_ctr += 1\n            else:\n                something_else_ctr += 1\n                continue\n\n            # Check if the item belongs to the specified user and was created 2 days ago\n            # if os.path.exists(path) and stat_info.st_uid == os.getpwnam(username).pw_uid and datetime.datetime.fromtimestamp(stat_info.st_ctime) &lt; cutoff_time:\n            try:\n                if datetime.fromtimestamp(stat_info.st_ctime) &lt; cutoff_time:\n                    if verbose:\n                        print(f\"Found user item '{path}'\")\n                    logging.info(f\"Found user item '{path}'\")\n\n                    try:\n                        if os.path.isfile(path):\n                            if no_test:\n                                os.remove(path)\n                                if verbose:\n                                    print(f\"Deleted file: {path}\")\n                                logging.info(f\"Deleted file: {path}\")\n                            else:\n                                if verbose:\n                                    print(f\"Running in test mode - so will not deleted file: {path}\")\n                                logging.info(f\"Running in test mode - so will not delete file: {path}\")\n                            delete_files_list.append(path)\n                            file_deleted_ctr += 1\n\n                        elif os.path.isdir(path):\n                            if no_test:\n                                shutil.rmtree(path)\n                                if verbose:\n                                    print(f\"Deleted directory: {path}\")\n                                logging.info(f\"Deleted directory: {path}\")\n                            else:\n                                if verbose:\n                                    print(f\"Running in test mode - so will not delete directory: {path}\")\n                                logging.info(f\"Running in test mode - so will not delete directory: {path}\")\n                            dir_deleted_ctr += 1\n                            delete_dirs_list.append(path)\n\n                    except Exception as e:\n                        print(f\"Error deleting {path}: {e}\")\n                        logging.error(f\"Error deleting {path}: {e}\")\n                else:\n                    if os.path.isfile(path):\n                        recent_file_ctr += 1\n                    elif os.path.isdir(path):\n                        recent_dir_ctr += 1\n                    else:\n                        recent_something_else_ctr += 1\n\n            except KeyError:\n                print(f\"User with UID {stat_info.st_uid} not found.\")\n                logging.error(f\"User with UID {stat_info.st_uid} not found.\")\n\n    if verbose:\n        print(f\"Ignored '{other_user_ctr}' items that belong to some other user\")\n\n        print(f\"Number of files analyzed '{file_ctr}'\")\n\n        print(f\"Number of directories analyzed '{dir_ctr}'\")\n\n        print(f\"Number of items analyzed that are neither files nor directories '{something_else_ctr}'\")\n\n        if no_test:\n            print(f\"Was running in test mode - so did not actually attempt to delete items belonging to user '{username}'\")\n\n        print(f\"Number of files deleted '{file_deleted_ctr}'\")\n\n        print(f\"Number of directories deleted '{dir_deleted_ctr}'\")\n\n        print(f\"Number of files that are too recent to be deleted '{recent_file_ctr}'\")\n\n        print(f\"Number of directories that are too recent to be deleted '{recent_dir_ctr}'\")\n\n        print(f\"Number of items that are neither files nor directories that are too recent to be deleted '{recent_something_else_ctr}'\")\n\n\n    logging.info(f\"Ignored '{other_user_ctr}' items that belong to some other user\")\n\n    logging.info(f\"Number of files analyzed '{file_ctr}'\")\n\n    logging.info(f\"Number of directories analyzed '{dir_ctr}'\")\n\n    logging.info(f\"Number of items analyzed that are neither files nor directories '{something_else_ctr}'\")\n\n    if no_test:\n        logging.info(f\"Was running in test mode - so did not actually attempt to delete items belonging to user '{username}'\")\n\n    logging.info(f\"Number of files deleted '{file_deleted_ctr}'\")\n\n    logging.info(f\"Number of directories deleted '{dir_deleted_ctr}'\")\n\n    logging.info(f\"Number of files that are too recent to be deleted '{recent_file_ctr}'\")\n\n    logging.info(f\"Number of directories that are too recent to be deleted '{recent_dir_ctr}'\")\n\n    logging.info(f\"Number of items that are neither files nor directories that are too recent to be deleted '{recent_something_else_ctr}'\")\n\n    generate_report(\n        no_test,\n        days_ago,\n        directory,\n        logfile,\n        username,\n        delete_files_list,\n        delete_dirs_list,\n        outfile)\n</code></pre>"},{"location":"delete_users_files/#data_file_utils.delete_users_files.generate_report","title":"<code>generate_report(no_test, days, indir, logfile, username, delete_files_list, delete_dirs_list, outfile=None)</code>","text":"<p>Generate a report of the files and directories that were deleted.</p> <p>Parameters:</p> Name Type Description Default <code>no_test</code> <code>bool</code> <p>If True, will not delete files and directories.  If False, will delete files and directories.</p> required <code>days</code> <code>int</code> <p>The minimum number of days ago that the files or directories were created.</p> required <code>indir</code> <code>str</code> <p>The directory to check for old files belonging to the specified user.</p> required <code>logfile</code> <code>str</code> <p>The log file.</p> required <code>username</code> <code>str</code> <p>The user that owns old files and directories to be deleted.</p> required <code>delete_files_list</code> <code>List[str]</code> <p>The list of files that were deleted.</p> required <code>delete_dirs_list</code> <code>List[str]</code> <p>The list of directories that were deleted.</p> required <code>outfile</code> <code>str</code> <p>The output report file. Defaults to None.</p> <code>None</code> Source code in <code>data_file_utils/delete_users_files.py</code> <pre><code>def generate_report(\n        no_test: bool,\n        days: int,\n        indir: str,\n        logfile: str,\n        username: str,\n        delete_files_list: List[str],\n        delete_dirs_list: List[str],\n        outfile: str = None):\n    \"\"\"Generate a report of the files and directories that were deleted.\n\n    Args:\n        no_test (bool): If True, will not delete files and directories.  If False, will delete files and directories.\n        days (int): The minimum number of days ago that the files or directories were created.\n        indir (str): The directory to check for old files belonging to the specified user.\n        logfile (str): The log file.\n        username (str): The user that owns old files and directories to be deleted.\n        delete_files_list (List[str]): The list of files that were deleted.\n        delete_dirs_list (List[str]): The list of directories that were deleted.\n        outfile (str, optional): The output report file. Defaults to None.\n    \"\"\"\n    with open(outfile, 'w') as of:\n        of.write(f\"## method-created: {os.path.abspath(__file__)}\\n\")\n        of.write(f\"## date-created: {str(datetime.today().strftime('%Y-%m-%d-%H%M%S'))}\\n\")\n        of.write(f\"## created-by: {os.environ.get('USER')}\\n\")\n        of.write(f\"## indir: {indir}\\n\")\n        of.write(f\"## logfile: {logfile}\\n\")\n        of.write(f\"## username: {username}\\n\")\n        of.write(f\"## days-old: {days}\\n\")\n        of.write(f\"## no-test-mode: {no_test}\\n\")\n\n        if len(delete_files_list) &gt; 0:\n            if no_test:\n                of.write(f\"## Deleted the following '{len(delete_files_list)}' files:\\n\")\n            else:\n                of.write(f\"## Would have deleted the following '{len(delete_files_list)}' files:\\n\")\n            for i, file in enumerate(delete_files_list, start=1):\n                of.write(f\"{i}. {file}\\n\")\n\n        if len(delete_dirs_list) &gt; 0:\n            if no_test:\n                of.write(f\"## Deleted the following '{len(delete_dirs_list)}' directoriess:\\n\")\n            else:\n                of.write(f\"## Would have deleted the following '{len(delete_dirs_list)}' directories:\\n\")\n            for i, dir in enumerate(delete_dirs_list, start=1):\n                of.write(f\"{i}. {dir}\\n\")\n\n    logging.info(f\"Wrote file report file '{outfile}'\")\n    print(f\"Wrote file report file '{outfile}'\")\n</code></pre>"},{"location":"delete_users_files/#data_file_utils.delete_users_files.main","title":"<code>main(days, indir, logfile, no_test, outdir, outfile, username, verbose)</code>","text":"<p>Delete user's old files.</p> <p>Parameters:</p> Name Type Description Default <code>days</code> <code>Optional[int]</code> <p>The number of days ago that files were created that should be deleted.</p> required <code>indir</code> <code>Optional[str]</code> <p>The directory to search for old user's files.</p> required <code>logfile</code> <code>Optional[str]</code> <p>The log file.</p> required <code>no_test</code> <code>Optional[bool]</code> <p>If specified, will actually delete files and directories.</p> required <code>outdir</code> <code>Optional[str]</code> <p>The output directory.</p> required <code>outfile</code> <code>Optional[str]</code> <p>The output report file.</p> required <code>username</code> <code>Optional[str]</code> <p>The username of the account whose old files should be deleted.</p> required <code>verbose</code> <code>Optional[bool]</code> <p>Will print more info to STDOUT.</p> required Source code in <code>data_file_utils/delete_users_files.py</code> <pre><code>@click.command()\n@click.option('--days', help=f\"Optional: The number of days ago that files were created that should be deleted - default is '{DEFAULT_DAYS_OLD}'\")\n@click.option('--indir', help=f\"Optional: The directory to search for old user's files - default is '{DEFAULT_INDIR}'\")\n@click.option('--logfile', help=\"Optional: The log file\")\n@click.option('--no-test', is_flag=True, help=f\"Optional: If specified, will actually delete files and directories - default is '{DEFAULT_NO_TEST_MODE}'\", callback=validate_no_test_mode)\n@click.option('--outdir', help=f\"Optional: The default is the current working directory - default is '{DEFAULT_OUTDIR}'\")\n@click.option('--outfile', help=\"Optional: The output report file\")\n@click.option('--username', help=f\"Optional: The username of the account whose old files should be deleted - default is '{DEFAULT_USERNAME}'\")\n@click.option('--verbose', is_flag=True, help=f\"Optional: Will print more info to STDOUT - default is '{DEFAULT_VERBOSE}'.\", callback=validate_verbose)\ndef main(days: Optional[int], indir: Optional[str], logfile: Optional[str], no_test: Optional[bool], outdir: Optional[str], outfile: Optional[str], username: Optional[str], verbose: Optional[bool]):\n    \"\"\"Delete user's old files.\n\n    Args:\n        days (Optional[int]): The number of days ago that files were created that should be deleted.\n        indir (Optional[str]): The directory to search for old user's files.\n        logfile (Optional[str]): The log file.\n        no_test (Optional[bool]): If specified, will actually delete files and directories.\n        outdir (Optional[str]): The output directory.\n        outfile (Optional[str]): The output report file.\n        username (Optional[str]): The username of the account whose old files should be deleted.\n        verbose (Optional[bool]): Will print more info to STDOUT.\n    \"\"\"\n\n    error_ctr = 0\n\n    if error_ctr &gt; 0:\n        click.echo(click.get_current_context().get_help())\n        sys.exit(1)\n\n    if indir is None:\n        indir = DEFAULT_INDIR\n        console.print(f\"[yellow]--indir was not specified and therefore was set to '{indir}'[/]\")\n\n    check_indir_status(indir)\n\n    if username is None:\n        username = DEFAULT_USERNAME\n        console.print(f\"[yellow]--username was not specified and therefore was set to '{username}'[/]\")\n\n    if no_test is None:\n        no_test = DEFAULT_NO_TEST_MODE\n        console.print(f\"[yellow]--no_test was not specified and therefore was set to '{no_test}'[/]\")\n\n    if days is None:\n        days = DEFAULT_DAYS_OLD\n        console.print(f\"[yellow]--days was not specified and therefore was set to '{days}'[/]\")\n\n    if outdir is None:\n        outdir = DEFAULT_OUTDIR\n        console.print(f\"[yellow]--outdir was not specified and therefore was set to '{outdir}'[/]\")\n\n    if not os.path.exists(outdir):\n        pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)\n        console.print(f\"[yellow]Created output directory '{outdir}'[/]\")\n\n    if logfile is None:\n        logfile = os.path.join(\n            outdir,\n            os.path.splitext(os.path.basename(__file__))[0] + '.log'\n        )\n        console.print(f\"[yellow]--logfile was not specified and therefore was set to '{logfile}'[/]\")\n\n    if outfile is None:\n        outfile = os.path.join(\n            outdir,\n            os.path.splitext(os.path.basename(__file__))[0] + '.report.txt'\n        )\n        console.print(f\"[yellow]--outfile was not specified and therefore was set to '{outfile}'[/]\")\n\n    if verbose is None:\n        verbose = DEFAULT_VERBOSE\n        console.print(f\"[yellow]--verbose was not specified and therefore was set to '{verbose}'[/]\")\n\n    logging.basicConfig(\n        filename=logfile,\n        format=DEFAULT_LOGGING_FORMAT,\n        level=DEFAULT_LOGGING_LEVEL,\n    )\n\n    if not no_test:\n        print(\"Running in test mode.\\nWill not actually delete files and directories.\\nTry --no-test to actually delete files and directories \")\n    else:\n        print(\"Will actually delete files and directories\")\n\n    delete_files_created_by_user(\n        logfile,\n        outfile,\n        indir,\n        username,\n        days,\n        no_test,\n        verbose,\n    )\n\n    if verbose:\n        console.print(f\"The log file is '{logfile}'\")\n        console.print(f\"[bold green]Execution of '{os.path.abspath(__file__)}' completed[/]\")\n    sys.exit(0)\n</code></pre>"},{"location":"delete_users_files/#data_file_utils.delete_users_files.validate_no_test_mode","title":"<code>validate_no_test_mode(ctx, param, value)</code>","text":"<p>Validate the no_test flag.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The click context.</p> required <code>param</code> <code>str</code> <p>The parameter name.</p> required <code>value</code> <code>bool</code> <p>The value of the parameter.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>The value of the parameter.</p> Source code in <code>data_file_utils/delete_users_files.py</code> <pre><code>def validate_no_test_mode(ctx, param, value):\n    \"\"\"Validate the no_test flag.\n\n    Args:\n        ctx (Context): The click context.\n        param (str): The parameter name.\n        value (bool): The value of the parameter.\n\n    Returns:\n        bool: The value of the parameter.\n    \"\"\"\n    if value is None:\n        click.secho(\"--no_test was not specified and therefore was set to 'True'\", fg='yellow')\n        return DEFAULT_NO_TEST_MODE\n    # else:\n    #     print(value)\n    return value\n</code></pre>"},{"location":"delete_users_files/#data_file_utils.delete_users_files.validate_verbose","title":"<code>validate_verbose(ctx, param, value)</code>","text":"<p>Validate the verbose flag.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The click context.</p> required <code>param</code> <code>str</code> <p>The parameter name.</p> required <code>value</code> <code>bool</code> <p>The value of the parameter.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>The value of the parameter.</p> Source code in <code>data_file_utils/delete_users_files.py</code> <pre><code>def validate_verbose(ctx, param, value):\n    \"\"\"Validate the verbose flag.\n\n    Args:\n        ctx (Context): The click context.\n        param (str): The parameter name.\n        value (bool): The value of the parameter.\n\n    Returns:\n        bool: The value of the parameter.\n    \"\"\"\n    if value is None:\n        click.secho(\"--verbose was not specified and therefore was set to 'True'\", fg='yellow')\n        return DEFAULT_VERBOSE\n    return value\n</code></pre>"},{"location":"file_utils/","title":"File Utils module","text":""},{"location":"file_utils/#data_file_utils.file_utils.calculate_md5","title":"<code>calculate_md5(file_path)</code>","text":"<p>Calculate the md5 checksum for the specified file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>the file for which the md5 checksum will be calculated</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the calculated md5 checksum</p> Source code in <code>data_file_utils/file_utils.py</code> <pre><code>def calculate_md5(file_path: str) -&gt; str:\n    \"\"\"Calculate the md5 checksum for the specified file.\n\n    Args:\n        file_path (str): the file for which the md5 checksum will be calculated\n\n    Returns:\n        str: the calculated md5 checksum\n    \"\"\"\n    md5_hash = hashlib.md5()\n    logging.info(f\"Will attempt to calculate the MD5 checksum for file '{file_path}'\")\n\n    with open(file_path, \"rb\") as file:\n        # Read the file in chunks to efficiently handle large files\n        for chunk in iter(lambda: file.read(4096), b\"\"):\n            md5_hash.update(chunk)\n\n    return md5_hash.hexdigest()\n</code></pre>"},{"location":"file_utils/#data_file_utils.file_utils.check_indir_status","title":"<code>check_indir_status(indir=None)</code>","text":"<p>Check if the directory exists and is a regular directory.</p> <p>Parameters:</p> Name Type Description Default <code>indir</code> <code>str</code> <p>the directory to be checked</p> <code>None</code> Source code in <code>data_file_utils/file_utils.py</code> <pre><code>def check_indir_status(indir: str = None) -&gt; None:\n    \"\"\"Check if the directory exists and is a regular directory.\n\n    Args:\n        indir (str): the directory to be checked\n    \"\"\"\n    error_ctr = 0\n\n    if indir is None or indir == '':\n        error_console.print(f\"'{indir}' is not defined\")\n        error_ctr += 1\n    else:\n        if not os.path.exists(indir):\n            error_ctr += 1\n            error_console.print(f\"directory '{indir}' does not exist\")\n        else:\n            if not os.path.isdir(indir):\n                error_ctr += 1\n                error_console.print(f\"'{indir}' is not a regular directory\")\n\n    if error_ctr &gt; 0:\n        error_console.print(f\"Detected problems with input directory '{indir}'\")\n        sys.exit(1)\n</code></pre>"},{"location":"file_utils/#data_file_utils.file_utils.check_infile_status","title":"<code>check_infile_status(infile, extension=None)</code>","text":"<p>Check if the file exists, if it is a regular file and whether it has content.</p> <p>Parameters:</p> Name Type Description Default <code>infile</code> <code>str</code> <p>the file to be checked</p> required Source code in <code>data_file_utils/file_utils.py</code> <pre><code>def check_infile_status(infile: str, extension: Optional[str] = None) -&gt; None:\n    \"\"\"Check if the file exists, if it is a regular file and whether it has\n    content.\n\n    Args:\n        infile (str): the file to be checked\n\n    Raises:\n        None\n    \"\"\"\n\n    error_ctr = 0\n\n    if infile is None or infile == \"\":\n        error_console.print(f\"'{infile}' is not defined\")\n        error_ctr += 1\n    else:\n        if not os.path.exists(infile):\n            error_ctr += 1\n            error_console.print(f\"'{infile}' does not exist\")\n        else:\n            if not os.path.isfile(infile):\n                error_ctr += 1\n                error_console.print(f\"'{infile}' is not a regular file\")\n            if os.stat(infile).st_size == 0:\n                error_console.print(f\"'{infile}' has no content\")\n                error_ctr += 1\n            if extension is not None and not infile.endswith(extension):\n                error_console.print(\n                    f\"'{infile}' does not have filename extension '{extension}'\"\n                )\n                error_ctr += 1\n\n    if error_ctr &gt; 0:\n        error_console.print(f\"Detected problems with input file '{infile}'\")\n        sys.exit(1)\n</code></pre>"},{"location":"file_utils/#data_file_utils.file_utils.get_file_creation_date","title":"<code>get_file_creation_date(file_path)</code>","text":"<p>Determine the creation date for the specified file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>the absolute path of the file</p> required <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>the date the file was created according to the operating system</p> Source code in <code>data_file_utils/file_utils.py</code> <pre><code>def get_file_creation_date(file_path: str) -&gt; datetime:\n    \"\"\"Determine the creation date for the specified file.\n\n    Args:\n        file_path (str): the absolute path of the file\n\n    Returns:\n        datetime: the date the file was created according to the operating system\n    \"\"\"\n    if platform.system() == \"Windows\":\n        # On Windows, use creation time\n        creation_time = os.path.getctime(file_path)\n    else:\n        # On Unix-based systems, use birth time (creation time)\n        # Note: Not all file systems support birth time, and it might not be available on some systems.\n        stat_info = os.stat(file_path)\n        creation_time = stat_info.st_mtime\n\n    # Convert the timestamp to a readable date\n    creation_date = datetime.fromtimestamp(creation_time)\n\n    return creation_date\n</code></pre>"},{"location":"file_utils/#data_file_utils.file_utils.get_file_list_from_directory","title":"<code>get_file_list_from_directory(indir=None, extension=None)</code>","text":"<p>Get the list of files in the specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>indir</code> <code>str</code> <p>The directory to search for files.</p> <code>None</code> <code>extension</code> <code>str</code> <p>The file extension to filter on.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>List[str]: The list of files found in the directory.</p> Source code in <code>data_file_utils/file_utils.py</code> <pre><code>def get_file_list_from_directory(indir: str = None, extension: str = None) -&gt; list:\n    \"\"\"Get the list of files in the specified directory.\n\n    Args:\n        indir (str): The directory to search for files.\n        extension (str): The file extension to filter on.\n\n    Returns:\n        List[str]: The list of files found in the directory.\n    \"\"\"\n    if extension is None:\n        logging.info(f\"Going to search for files in directory '{indir}'\")\n    else:\n        logging.info(f\"Going to search for files with extension '{extension}' in directory '{indir}'\")\n\n    file_list = []\n    for dirpath, dirnames, filenames in os.walk(indir):\n        if 'venv' in dirpath:\n            logging.info(f\"Going to ignore files in directory '{dirpath}'\")\n            continue\n        for name in filenames:\n            file_path = os.path.normpath(os.path.join(dirpath, name))\n            if os.path.isfile(file_path):\n                if extension is not None:\n                    if file_path.endswith(f'.{extension}'):\n                        file_list.append(file_path)\n                else:\n                    file_list.append(file_path)\n\n    return file_list\n</code></pre>"},{"location":"file_utils/#data_file_utils.file_utils.get_file_size","title":"<code>get_file_size(file_path)</code>","text":"<p>Get the size of the specified file in bytes.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file to be checked.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the file does not exist.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The size of the file in bytes.</p> Source code in <code>data_file_utils/file_utils.py</code> <pre><code>def get_file_size(file_path: str) -&gt; int:\n    \"\"\"Get the size of the specified file in bytes.\n\n    Args:\n        file_path (str): The path to the file to be checked.\n\n    Raises:\n        Exception: If the file does not exist.\n\n    Returns:\n        int: The size of the file in bytes.\n    \"\"\"\n    # Check if the file exists\n    if os.path.exists(file_path):\n        # Get the file size in bytes\n        file_size = os.path.getsize(file_path)\n        return file_size\n    else:\n        raise Exception(f\"The file '{file_path}' does not exist.\")\n</code></pre>"},{"location":"file_utils/#data_file_utils.file_utils.get_line_count","title":"<code>get_line_count(file_path)</code>","text":"<p>Get the number of lines in the specified file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file to be checked.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of lines in the file.</p> Source code in <code>data_file_utils/file_utils.py</code> <pre><code>def get_line_count(file_path: str) -&gt; int:\n    \"\"\"Get the number of lines in the specified file.\n\n    Args:\n        file_path (str): The path to the file to be checked.\n\n    Returns:\n        int: The number of lines in the file.\n    \"\"\"\n    # if is_binary_file(file_path):\n    #     print(f\"Unable to get line count for binary file '{file_path}'\")\n    #     return None\n    try:\n        with open(file_path, 'r') as file:\n            line_count = sum(1 for line in file)\n        return line_count\n    except FileNotFoundError:\n        print(f\"File '{file_path}' not found.\")\n        return None\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return None\n</code></pre>"},{"location":"file_utils/#data_file_utils.file_utils.is_binary_file","title":"<code>is_binary_file(file_path, block_size=1024)</code>","text":"<p>Check if the specified file is a binary file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file to be checked.</p> required <code>block_size</code> <code>int</code> <p>The block size. Defaults to 1024.</p> <code>1024</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>If the file is binary, returns True. Otherwise, returns False.</p> Source code in <code>data_file_utils/file_utils.py</code> <pre><code>def is_binary_file(file_path: str, block_size: int = 1024) -&gt; bool:\n    \"\"\"Check if the specified file is a binary file.\n\n    Args:\n        file_path (str): The path to the file to be checked.\n        block_size (int, optional): The block size. Defaults to 1024.\n\n    Returns:\n        bool: If the file is binary, returns True. Otherwise, returns False.\n    \"\"\"\n    try:\n        with open(file_path, 'rb') as file:\n            block = file.read(block_size)\n            if not block:  # Empty file\n                return False\n\n            # Check for the presence of null bytes (indicative of binary files)\n            if b'\\x00' in block:\n                return True\n\n            # Check for a significant number of non-printable ASCII characters\n            text_characters = set(string.printable)\n            if not all(byte in text_characters or byte == b'\\n' for byte in block):\n                return True\n\n            return False  # File is likely text\n\n    except FileNotFoundError:\n        print(f\"File '{file_path}' not found.\")\n        return None\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return None\n</code></pre>"},{"location":"find_last_directory/","title":"Find Last Directory module","text":"<p>Find the last directory in the specified directory given a directory pattern.</p>"},{"location":"find_last_directory/#data_file_utils.find_last_directory.find_most_recent_version_directory","title":"<code>find_most_recent_version_directory(directory, dir_pattern)</code>","text":"<p>Find the most recent version directory in the specified directory pattern.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>The directory to search for the most recent version directory.</p> required <code>dir_pattern</code> <code>str</code> <p>The directory pattern to filter for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>The most recent version directory.</p> Source code in <code>data_file_utils/find_last_directory.py</code> <pre><code>def find_most_recent_version_directory(directory: str, dir_pattern: str) -&gt; Optional[str]:\n    \"\"\"Find the most recent version directory in the specified directory pattern.\n\n    Args:\n        directory (str): The directory to search for the most recent version directory.\n        dir_pattern (str): The directory pattern to filter for.\n\n    Returns:\n        str: The most recent version directory.\n    \"\"\"\n    # Get a list of all files in the directory\n    all_files = os.listdir(directory)\n\n    if not all_files:\n        console.print(f\"Directory '{directory}' is empty.\")\n        return None\n\n    # Create a dictionary to store file paths and their creation times\n    dir_times = {}\n\n    if dir_pattern:\n        # Filter files based on the provided pattern and extension\n        matching_dirs = [file for file in all_files if re.match(dir_pattern, file)]\n    else:\n        matching_dirs = [file for file in all_files]\n\n\n    if not matching_dirs:\n        console.print(f\"No matching directories found in directory '{directory}'.\")\n        return None\n\n    for dir in matching_dirs:\n        dir_path = os.path.join(directory, dir)\n\n        # Check if it's a dir (not a directory)\n        if os.path.isdir(dir_path):\n            # Get the dir creation time (Linux timestamp)\n            creation_time = os.path.getctime(dir_path)\n            # Store the dir path and creation time in the dictionary\n            dir_times[dir_path] = creation_time\n\n    if not dir_times:\n        console.print(f\"No valid dirs found in the directory '{directory}'.\")\n        return None\n\n    # Find the dir with the highest creation time\n    most_recent_dir = max(dir_times, key=dir_times.get)\n\n    return most_recent_dir\n</code></pre>"},{"location":"find_last_directory/#data_file_utils.find_last_directory.main","title":"<code>main(config_file, indir, logfile, no_details, outdir, outfile, pattern, verbose)</code>","text":"<p>Find most recent set of assets in specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Optional[str]</code> <p>The configuration file for this project.</p> required <code>indir</code> <code>str</code> <p>The input directory to check for assets.</p> required <code>logfile</code> <code>Optional[str]</code> <p>The log file.</p> required <code>no_details</code> <code>Optional[bool]</code> <p>If specified, will not show file details.</p> required <code>outdir</code> <code>Optional[str]</code> <p>The output directory.</p> required <code>outfile</code> <code>Optional[str]</code> <p>The output final report file.</p> required <code>pattern</code> <code>Optional[str]</code> <p>The filename pattern to filter for.</p> required <code>verbose</code> <code>Optional[bool]</code> <p>Will print more info to STDOUT.</p> required Source code in <code>data_file_utils/find_last_directory.py</code> <pre><code>@click.command()\n@click.option('--config_file', type=click.Path(exists=True), help=f\"Optional: The configuration file for this project - default is '{DEFAULT_CONFIG_FILE}'.\")\n@click.option('--indir', help=\"Optional: The input directory to check for assets.\")\n@click.option('--logfile', help=\"Optional: The log file\")\n@click.option('--no_details', is_flag=True, help=f\"Optional: If specified, will not show file details - default is '{DEFAULT_NO_DETAILS}'\")\n@click.option('--outdir', help=f\"Optional: The default is the current working directory - default is '{DEFAULT_OUTDIR}'\")\n@click.option('--outfile', help=\"Optional: The output final report file\")\n@click.option('--pattern', help=\"Optional: the filename pattern to filter for\")\n@click.option('--verbose', is_flag=True, help=f\"Optional: Will print more info to STDOUT - default is '{DEFAULT_VERBOSE}'.\", callback=validate_verbose)\ndef main(config_file: Optional[str], indir: str, logfile: Optional[str], no_details: Optional[bool], outdir: Optional[str], outfile: Optional[str], pattern: Optional[str], verbose: Optional[bool]):\n    \"\"\"Find most recent set of assets in specified directory.\n\n    Args:\n        config_file (Optional[str]): The configuration file for this project.\n        indir (str): The input directory to check for assets.\n        logfile (Optional[str]): The log file.\n        no_details (Optional[bool]): If specified, will not show file details.\n        outdir (Optional[str]): The output directory.\n        outfile (Optional[str]): The output final report file.\n        pattern (Optional[str]): The filename pattern to filter for.\n        verbose (Optional[bool]): Will print more info to STDOUT.\n    \"\"\"\n    error_ctr = 0\n\n    if error_ctr &gt; 0:\n        click.echo(click.get_current_context().get_help())\n        sys.exit(1)\n\n    if config_file is None:\n        config_file = DEFAULT_CONFIG_FILE\n        print_yellow(f\"--config_file was not specified and therefore was set to '{config_file}'\")\n\n    if indir is None:\n        indir = os.path.abspath(os.getcwd())\n        print_yellow(f\"--indir was not specified and therefore was set to '{indir}'\")\n\n    if no_details is None:\n        no_details = DEFAULT_NO_DETAILS\n        print_yellow(f\"--no_details was not specified and therefore was set to '{no_details}'\")\n\n    if outdir is None:\n        outdir = DEFAULT_OUTDIR\n        print_yellow(f\"--outdir was not specified and therefore was set to '{outdir}'\")\n\n\n    if not os.path.exists(outdir):\n        pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)\n        print_yellow(f\"Created output directory '{outdir}'\")\n\n    if logfile is None:\n        logfile = os.path.join(\n            outdir,\n            os.path.splitext(os.path.basename(__file__))[0] + '.log'\n        )\n        print_yellow(f\"--logfile was not specified and therefore was set to '{logfile}'\")\n\n\n    logging.basicConfig(\n        filename=logfile,\n        format=DEFAULT_LOGGING_FORMAT,\n        level=DEFAULT_LOGGING_LEVEL,\n    )\n\n    check_infile_status(config_file, \"yaml\")\n\n    logging.info(f\"Will load contents of config file '{config_file}'\")\n    config = yaml.safe_load(Path(config_file).read_text())\n\n    logging.info(f\"{indir=}\")\n    item = find_most_recent_version_directory(\n        directory=indir,\n        dir_pattern=pattern,\n    )\n    if item is not None:\n        console.print(f\"Found this latest directory: {item}\")\n        profile_directory(item, no_details=no_details)\n\n    if verbose:\n        console.print(f\"The log file is '{logfile}'\")\n        print_green(f\"Execution of '{os.path.abspath(__file__)}' completed\")\n</code></pre>"},{"location":"find_last_directory/#data_file_utils.find_last_directory.profile_directory","title":"<code>profile_directory(indir, no_details=False)</code>","text":"<p>Profile the files in the specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>indir</code> <code>str</code> <p>The input directory to check for assets.</p> required <code>no_details</code> <code>bool</code> <p>If True, print more details to STDOUT. Defaults to False.</p> <code>False</code> Source code in <code>data_file_utils/find_last_directory.py</code> <pre><code>def profile_directory(indir: str, no_details: bool = False) -&gt; None:\n    \"\"\"Profile the files in the specified directory.\n\n    Args:\n        indir (str): The input directory to check for assets.\n        no_details (bool, optional): If True, print more details to STDOUT. Defaults to False.\n    \"\"\"\n    file_list = get_file_list(indir)\n\n    console.print(f\"Found the following '{len(file_list)}' files:\")\n\n    for f in file_list:\n        profile_file(f, no_details)\n</code></pre>"},{"location":"find_last_directory/#data_file_utils.find_last_directory.profile_file","title":"<code>profile_file(infile, no_details=False)</code>","text":"<p>Profile the specified file.</p> <p>Parameters:</p> Name Type Description Default <code>infile</code> <code>str</code> <p>The input file to profile.</p> required <code>no_details</code> <code>bool</code> <p>If True, print more details to STDOUT. Defaults to False.</p> <code>False</code> Source code in <code>data_file_utils/find_last_directory.py</code> <pre><code>def profile_file(infile: str, no_details: bool = False) -&gt; None:\n    \"\"\"Profile the specified file.\n\n    Args:\n        infile (str): The input file to profile.\n        no_details (bool, optional): If True, print more details to STDOUT. Defaults to False.\n    \"\"\"\n    print_green(f\"[bold green]{os.path.realpath(infile)}\")\n    if not no_details:\n        checksum = calculate_md5(infile)\n        date_created = get_file_creation_date(infile)\n        bytesize = get_file_size(infile)\n        line_count = get_line_count(infile)\n        console.print(f\"[blue]md5sum:[/] {checksum}\")\n        console.print(f\"[blue]date-created/modified:[/] {date_created}\")\n        console.print(f\"[blue]size:[/] {bytesize}\")\n        console.print(f\"[blue]line-count:[/] {line_count}\")\n</code></pre>"},{"location":"find_last_directory/#data_file_utils.find_last_directory.validate_verbose","title":"<code>validate_verbose(ctx, param, value)</code>","text":"<p>Validate the verbose flag.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The click context.</p> required <code>param</code> <code>str</code> <p>The parameter name.</p> required <code>value</code> <code>bool</code> <p>The value of the parameter.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>The value of the parameter.</p> Source code in <code>data_file_utils/find_last_directory.py</code> <pre><code>def validate_verbose(ctx, param, value):\n    \"\"\"Validate the verbose flag.\n\n    Args:\n        ctx (Context): The click context.\n        param (str): The parameter name.\n        value (bool): The value of the parameter.\n\n    Returns:\n        bool: The value of the parameter.\n    \"\"\"\n    if value is None:\n        click.secho(\"--verbose was not specified and therefore was set to 'True'\", fg='yellow')\n        return DEFAULT_VERBOSE\n    return value\n</code></pre>"},{"location":"find_last_file/","title":"Find Last File module","text":"<p>Find the last file in a directory.</p>"},{"location":"find_last_file/#data_file_utils.find_last_file.find_most_recent_version_file","title":"<code>find_most_recent_version_file(directory, file_pattern, file_extension=None)</code>","text":"<p>Find the most recent version file in the specified directory based on the specified pattern.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>The directory to search for the most recent file.</p> required <code>file_pattern</code> <code>str</code> <p>The pattern to use to filter the files.</p> required <code>file_extension</code> <code>str</code> <p>The file extension. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>data_file_utils/find_last_file.py</code> <pre><code>def find_most_recent_version_file(directory: str, file_pattern: str, file_extension: str = None):\n    \"\"\"Find the most recent version file in the specified directory based on the specified pattern.\n\n    Args:\n        directory (str): The directory to search for the most recent file.\n        file_pattern (str): The pattern to use to filter the files.\n        file_extension (str, optional): The file extension. Defaults to None.\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    # Get a list of all files in the directory\n    all_files = os.listdir(directory)\n\n    if not all_files:\n        print(f\"Directory '{directory}' is empty.\")\n        return None\n\n    # Create a dictionary to store file paths and their creation times\n    file_times = {}\n    matching_files = None\n\n    if file_pattern and file_extension:\n        # Filter files based on the provided pattern and extension\n        matching_files = [file for file in all_files if re.match(file_pattern, file) and (file_extension is None or file.endswith(file_extension))]\n    elif file_pattern:\n        matching_files = [file for file in all_files if re.match(file_pattern, file)]\n    elif file_extension:\n        matching_files = [file for file in all_files if file.endswith(file_extension)]\n    else:\n        matching_files = [file for file in all_files]\n\n\n    if not matching_files:\n        print(f\"No matching files found in directory '{directory}'.\")\n        return None\n\n    for file in matching_files:\n        file_path = os.path.join(directory, file)\n\n        # Check if it's a file (not a directory)\n        if os.path.isfile(file_path):\n            # Get the file creation time (Linux timestamp)\n            creation_time = os.path.getctime(file_path)\n            # Store the file path and creation time in the dictionary\n            file_times[file_path] = creation_time\n\n    if not file_times:\n        print(f\"No valid files found in the directory '{directory}'.\")\n        return None\n\n    # Find the file with the highest creation time\n    most_recent_file = max(file_times, key=file_times.get)\n\n    return most_recent_file\n</code></pre>"},{"location":"find_last_file/#data_file_utils.find_last_file.main","title":"<code>main(config_file, extension, indir, logfile, no_details, outdir, outfile, pattern, verbose)</code>","text":"<p>Find most recent set of assets in specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Optional[str]</code> <p>The configuration file for this project.</p> required <code>extension</code> <code>Optional[str]</code> <p>The filename extension to filter for.</p> required <code>indir</code> <code>Optional[str]</code> <p>The input directory to check for assets - default is current working directory.</p> required <code>logfile</code> <code>Optional[str]</code> <p>The log file.</p> required <code>no_details</code> <code>Optional[bool]</code> <p>If specified, will not profile the files.</p> required <code>outdir</code> <code>Optional[str]</code> <p>The output directory.</p> required <code>outfile</code> <code>Optional[str]</code> <p>The output final report file.</p> required <code>pattern</code> <code>Optional[str]</code> <p>The filename pattern to filter for.</p> required <code>verbose</code> <code>Optional[bool]</code> <p>Will print more info to STDOUT.</p> required Source code in <code>data_file_utils/find_last_file.py</code> <pre><code>@click.command()\n@click.option('--config_file', type=click.Path(exists=True), help=f\"Optional:The configuration file for this project - default is '{DEFAULT_CONFIG_FILE}'\")\n@click.option('--extension', help=\"Optional: the filename extension to filter for\")\n@click.option('--indir', help=\"Optional: the input directory to check for assets\")\n@click.option('--logfile', help=\"Optional:The log file\")\n@click.option('--no_details', is_flag=True, help=f\"Optional: If specified, will not show file details - default is '{DEFAULT_NO_DETAILS}'\")\n@click.option('--outdir', help=f\"Optional: The default is the current working directory - default is '{DEFAULT_OUTDIR}'\")\n@click.option('--outfile', help=\"Optional: The output final report file\")\n@click.option('--pattern', help=\"Optional: the filename pattern to filter for\")\n@click.option('--verbose', is_flag=True, help=f\"Optional: Will print more info to STDOUT - default is '{DEFAULT_VERBOSE}'.\", callback=validate_verbose)\ndef main(config_file: Optional[str], extension: Optional[str], indir: Optional[str], logfile: Optional[str], no_details: Optional[bool], outdir: Optional[str], outfile: Optional[str], pattern: Optional[str], verbose: Optional[bool]):\n    \"\"\"Find most recent set of assets in specified directory.\n\n    Args:\n        config_file (Optional[str]): The configuration file for this project.\n        extension (Optional[str]): The filename extension to filter for.\n        indir (Optional[str]): The input directory to check for assets - default is current working directory.\n        logfile (Optional[str]): The log file.\n        no_details (Optional[bool]): If specified, will not profile the files.\n        outdir (Optional[str]): The output directory.\n        outfile (Optional[str]): The output final report file.\n        pattern (Optional[str]): The filename pattern to filter for.\n        verbose (Optional[bool]): Will print more info to STDOUT.\n    \"\"\"\n    error_ctr = 0\n\n    if error_ctr &gt; 0:\n        click.echo(click.get_current_context().get_help())\n        sys.exit(1)\n\n    if config_file is None:\n        config_file = DEFAULT_CONFIG_FILE\n        print_yellow(f\"--config_file was not specified and therefore was set to '{config_file}'\")\n\n    if indir is None:\n        indir = os.path.abspath(os.getcwd())\n        print_yellow(f\"--indir was not specified and therefore was set to '{indir}'\")\n\n    if no_details is None:\n        no_details = DEFAULT_NO_DETAILS\n        print_yellow(f\"--no_details was not specified and therefore was set to '{no_details}'\")\n\n    if outdir is None:\n        outdir = DEFAULT_OUTDIR\n        print_yellow(f\"--outdir was not specified and therefore was set to '{outdir}'\")\n\n\n    if not os.path.exists(outdir):\n        pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)\n        print_yellow(f\"Created output directory '{outdir}'\")\n\n    if logfile is None:\n        logfile = os.path.join(\n            outdir,\n            os.path.splitext(os.path.basename(__file__))[0] + '.log'\n        )\n        print_yellow(f\"--logfile was not specified and therefore was set to '{logfile}'\")\n\n\n    logging.basicConfig(\n        filename=logfile,\n        format=DEFAULT_LOGGING_FORMAT,\n        level=DEFAULT_LOGGING_LEVEL,\n    )\n\n    check_infile_status(config_file, \"yaml\")\n\n    logging.info(f\"Will load contents of config file '{config_file}'\")\n    config = yaml.safe_load(Path(config_file).read_text())\n\n    logging.info(f\"{indir=}\")\n    item = find_most_recent_version_file(\n        directory=indir,\n        file_pattern=pattern,\n        file_extension=extension,\n    )\n    if item is not None:\n        print(f\"Found this latest file: {item}\")\n        profile_file(item, no_details=no_details)\n\n    if verbose:\n        print(f\"The log file is '{logfile}'\")\n        print_green(f\"Execution of '{os.path.abspath(__file__)}' completed\")\n</code></pre>"},{"location":"find_last_file/#data_file_utils.find_last_file.profile_directory","title":"<code>profile_directory(indir, no_details=False)</code>","text":"<p>Search the directory for files.</p> <p>Parameters:</p> Name Type Description Default <code>indir</code> <code>str</code> <p>The input directory to check for files.</p> required <code>no_details</code> <code>bool</code> <p>If True, do not profile the files. Defaults to False.</p> <code>False</code> Source code in <code>data_file_utils/find_last_file.py</code> <pre><code>def profile_directory(indir: str, no_details: bool = False) -&gt; None:\n    \"\"\"Search the directory for files.\n\n    Args:\n        indir (str): The input directory to check for files.\n        no_details (bool, optional): If True, do not profile the files. Defaults to False.\n    \"\"\"\n    file_list = get_file_list(indir)\n\n    print(f\"Found the following '{len(file_list)}' files:\")\n\n    for f in file_list:\n        profile_file(f, no_details)\n</code></pre>"},{"location":"find_last_file/#data_file_utils.find_last_file.profile_file","title":"<code>profile_file(infile, no_details=False)</code>","text":"<p>Profile the specified file.</p> <p>Parameters:</p> Name Type Description Default <code>infile</code> <code>str</code> <p>The file to profile.</p> required <code>no_details</code> <code>bool</code> <p>If True, do not profile the file. Defaults to False.</p> <code>False</code> Source code in <code>data_file_utils/find_last_file.py</code> <pre><code>def profile_file(infile: str, no_details: bool = False) -&gt; None:\n    \"\"\"Profile the specified file.\n\n    Args:\n        infile (str): The file to profile.\n        no_details (bool, optional): If True, do not profile the file. Defaults to False.\n    \"\"\"\n    print_green(f\"[bold green]{os.path.realpath(infile)}\")\n    if not no_details:\n        checksum = calculate_md5(infile)\n        date_created = get_file_creation_date(infile)\n        bytesize = get_file_size(infile)\n        line_count = get_line_count(infile)\n        console.print(f\"[blue]md5sum:[/] {checksum}\")\n        console.print(f\"[blue]date-created/modified:[/] {date_created}\")\n        console.print(f\"[blue]size:[/] {bytesize}\")\n        console.print(f\"[blue]line-count:[/] {line_count}\")\n</code></pre>"},{"location":"find_last_file/#data_file_utils.find_last_file.validate_verbose","title":"<code>validate_verbose(ctx, param, value)</code>","text":"<p>Validate the verbose flag.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The click context.</p> required <code>param</code> <code>str</code> <p>The parameter name.</p> required <code>value</code> <code>bool</code> <p>The value of the parameter.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>The value of the parameter.</p> Source code in <code>data_file_utils/find_last_file.py</code> <pre><code>def validate_verbose(ctx, param, value):\n    \"\"\"Validate the verbose flag.\n\n    Args:\n        ctx (Context): The click context.\n        param (str): The parameter name.\n        value (bool): The value of the parameter.\n\n    Returns:\n        bool: The value of the parameter.\n    \"\"\"\n    if value is None:\n        click.secho(\"--verbose was not specified and therefore was set to 'True'\", fg='yellow')\n        return DEFAULT_VERBOSE\n    return value\n</code></pre>"},{"location":"jsonl2json/","title":"Jsonl2Json module","text":"<p>Parse JSONL file and write multiple JSON files.</p>"},{"location":"jsonl2json/#data_file_utils.jsonl2json.main","title":"<code>main(infile, logfile, outdir, verbose)</code>","text":"<p>Parse JSONL file and write multiple JSON files.</p> Source code in <code>data_file_utils/jsonl2json.py</code> <pre><code>@click.command()\n@click.option('--infile', help=\"Required: The input JSONL file (.jsonl)\")\n@click.option('--logfile', help=\"Optional: The log file\")\n@click.option('--outdir', help=\"Optional: The output directory where logfile and default output file will be written - default is '{DEFAULT_OUTDIR}'\")\n@click.option('--verbose', is_flag=True, help=f\"Optional: Will print more info to STDOUT - default is '{DEFAULT_VERBOSE}'.\", callback=validate_verbose)\ndef main(infile: str, logfile: Optional[str], outdir: Optional[str], verbose: Optional[bool]):\n    \"\"\"Parse JSONL file and write multiple JSON files.\"\"\"\n    error_ctr = 0\n\n    if infile is None:\n        print_red(\"--infile was not specified\")\n        error_ctr += 1\n\n    if error_ctr &gt; 0:\n        print_red(\"Required command-line arguments were not provided\")\n        click.echo(click.get_current_context().get_help())\n        sys.exit(1)\n\n    check_infile_status(infile, \"jsonl\")\n\n    if outdir is None:\n        outdir = DEFAULT_OUTDIR\n        print_yellow(f\"--outdir was not specified and therefore was set to '{outdir}'\")\n\n    if not os.path.exists(outdir):\n        pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)\n        print_yellow(f\"Created output directory '{outdir}'\")\n\n    if logfile is None:\n        logfile = os.path.join(\n            outdir,\n            os.path.splitext(os.path.basename(__file__))[0] + '.log'\n        )\n        print_yellow(f\"--logfile was not specified and therefore was set to '{logfile}'\")\n\n    # Set the root logger\n    logging.basicConfig(\n        filename=logfile,\n        format=DEFAULT_LOGGING_FORMAT,\n        level=DEFAULT_LOGGING_LEVEL,\n    )\n\n    parse_jsonl(infile, outdir)\n\n    if verbose:\n        console.print(f\"The log file is '{logfile}'\")\n        print_green(f\"Execution of '{os.path.abspath(__file__)}' completed\")\n</code></pre>"},{"location":"jsonl2json/#data_file_utils.jsonl2json.parse_jsonl","title":"<code>parse_jsonl(input_file, output_folder)</code>","text":"<p>Parse the JSONL file and write JSON files for each line.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>The file path for the input JSONL file.</p> required <code>output_folder</code> <code>str</code> <p>The output directory where the JSON files will be written to.</p> required Source code in <code>data_file_utils/jsonl2json.py</code> <pre><code>def parse_jsonl(input_file: str, output_folder: str) -&gt; None:\n    \"\"\"Parse the JSONL file and write JSON files for each line.\n\n    Args:\n        input_file (str): The file path for the input JSONL file.\n        output_folder (str): The output directory where the JSON files will be written to.\n    \"\"\"\n    with open(input_file, 'r') as jsonl_file:\n        for line_number, line in enumerate(jsonl_file, start=1):\n            try:\n                data = json.loads(line)\n            except json.JSONDecodeError as e:\n                print(f\"Error decoding JSON at line {line_number}: {e}\")\n                continue\n\n            output_file_path = os.path.join(output_folder, f\"output_{line_number}.json\")\n            with open(output_file_path, 'w') as output_file:\n                json.dump(data, output_file, indent=2)\n\n            print(f\"Processed line {line_number}. Output written to {output_file_path}\")\n</code></pre>"},{"location":"jsonl2json/#data_file_utils.jsonl2json.validate_verbose","title":"<code>validate_verbose(ctx, param, value)</code>","text":"<p>Validate the verbose flag.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The click context.</p> required <code>param</code> <code>str</code> <p>The parameter name.</p> required <code>value</code> <code>bool</code> <p>The value of the parameter.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>The value of the parameter.</p> Source code in <code>data_file_utils/jsonl2json.py</code> <pre><code>def validate_verbose(ctx, param, value):\n    \"\"\"Validate the verbose flag.\n\n    Args:\n        ctx (Context): The click context.\n        param (str): The parameter name.\n        value (bool): The value of the parameter.\n\n    Returns:\n        bool: The value of the parameter.\n    \"\"\"\n    if value is None:\n        click.secho(\"--verbose was not specified and therefore was set to 'True'\", fg='yellow')\n        return DEFAULT_VERBOSE\n    return value\n</code></pre>"},{"location":"profile_data_file/","title":"Profile Data File module","text":"<p>Profile the specified file.</p>"},{"location":"profile_data_file/#data_file_utils.profile_data_file.main","title":"<code>main(infile)</code>","text":"<p>Profile data file.</p> <p>Parameters:</p> Name Type Description Default <code>infile</code> <code>str</code> <p>The input file to profile.</p> required Source code in <code>data_file_utils/profile_data_file.py</code> <pre><code>@click.command()\n@click.argument('infile', type=str, required=True)\ndef main(infile: str):\n    \"\"\"Profile data file.\n\n    Args:\n        infile (str): The input file to profile.\n    \"\"\"\n\n    error_ctr = 0\n\n    if infile is None:\n        error_console.print(f\"Usage: {os.path.basename(__file__)} infile\")\n        error_ctr += 1\n\n    if error_ctr &gt; 0:\n        click.echo(click.get_current_context().get_help())\n        sys.exit(1)\n\n    check_infile_status(infile)\n\n    md5sum = calculate_md5(infile)\n    create_date = get_file_creation_date(infile)\n    file_size = get_file_size(infile)\n    line_count = get_line_count(infile)\n\n    print(f\"File: {os.path.abspath(infile)}\")\n    print(f\"md5sum: {md5sum}\")\n    print(f\"create_date: {create_date}\")\n    print(f\"byte_size: {file_size}\")\n    print(f\"line_count: {line_count}\")\n</code></pre>"},{"location":"tsv2json/","title":"Tsv2Json module","text":"<p>Convert the tab-delimited file to a JSON file.</p>"},{"location":"tsv2json/#data_file_utils.tsv2json.convert_file","title":"<code>convert_file(infile, outfile, header_line=DEFAULT_HEADER_LINE, start_line=DEFAULT_START_LINE, include_line_numbers=DEFAULT_INCLUDE_LINE_NUMBERS)</code>","text":"<p>Convert the tab-delimited file to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>infile</code> <code>str</code> <p>The tab-delimited file to be converted.</p> required <code>outfile</code> <code>str</code> <p>The output JSON file.</p> required <code>header_line</code> <code>int</code> <p>The line number that contains the column headers. Defaults to DEFAULT_HEADER_LINE.</p> <code>DEFAULT_HEADER_LINE</code> <code>start_line</code> <code>int</code> <p>The line number where the first record begins. Defaults to DEFAULT_START_LINE.</p> <code>DEFAULT_START_LINE</code> <code>include_line_numbers</code> <code>bool</code> <p>If True, the output will include the line number of the record in the source tab-delimited file. Defaults to DEFAULT_INCLUDE_LINE_NUMBERS.</p> <code>DEFAULT_INCLUDE_LINE_NUMBERS</code> Source code in <code>data_file_utils/tsv2json.py</code> <pre><code>def convert_file(\n    infile: str,\n    outfile: str,\n    header_line: int = DEFAULT_HEADER_LINE,\n    start_line: int = DEFAULT_START_LINE,\n    include_line_numbers: bool = DEFAULT_INCLUDE_LINE_NUMBERS\n) -&gt; None:\n    \"\"\"Convert the tab-delimited file to a JSON file.\n\n    Args:\n        infile (str): The tab-delimited file to be converted.\n        outfile (str): The output JSON file.\n        header_line (int, optional): The line number that contains the column headers. Defaults to DEFAULT_HEADER_LINE.\n        start_line (int, optional): The line number where the first record begins. Defaults to DEFAULT_START_LINE.\n        include_line_numbers (bool, optional): If True, the output will include the line number of the record in the source tab-delimited file. Defaults to DEFAULT_INCLUDE_LINE_NUMBERS.\n    \"\"\"\n\n    record_lookup = get_record_lookup(infile, header_line, start_line, include_line_numbers)\n    # Write the list of ordered dictionaries to a JSON file\n    lookup = {\n        \"infile\": os.path.abspath(infile),\n        \"records\": record_lookup\n    }\n    with open(outfile, 'w', encoding='utf-8') as json_file:\n        json.dump(lookup, json_file, indent=2)\n</code></pre>"},{"location":"tsv2json/#data_file_utils.tsv2json.get_record_lookup","title":"<code>get_record_lookup(infile, header_line=2, start_line=3, include_line_numbers=DEFAULT_INCLUDE_LINE_NUMBERS)</code>","text":"<p>Parse the input tab-delimited file and get the record lookup.</p> <p>Parameters:</p> Name Type Description Default <code>infile</code> <code>str</code> <p>The input tab-delimited file.</p> required <code>header_line</code> <code>int</code> <p>The line number at which the column headers can be found. Defaults to 2.</p> <code>2</code> <code>start_line</code> <code>int</code> <p>The line number at which the first record can be found. Defaults to 3.</p> <code>3</code> <code>include_line_numbers</code> <code>bool</code> <p>If True, the line numbers will be included in the record objects in the JSON file. Defaults to DEFAULT_INCLUDE_LINE_NUMBERS.</p> <code>DEFAULT_INCLUDE_LINE_NUMBERS</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the input file does not exist.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The record lookup.</p> Source code in <code>data_file_utils/tsv2json.py</code> <pre><code>def get_record_lookup(infile: str, header_line: int = 2, start_line: int = 3, include_line_numbers: bool = DEFAULT_INCLUDE_LINE_NUMBERS) -&gt; Dict[str, Any]:\n    \"\"\"Parse the input tab-delimited file and get the record lookup.\n\n    Args:\n        infile (str): The input tab-delimited file.\n        header_line (int, optional): The line number at which the column headers can be found. Defaults to 2.\n        start_line (int, optional): The line number at which the first record can be found. Defaults to 3.\n        include_line_numbers (bool, optional): If True, the line numbers will be included in the record objects in the JSON file. Defaults to DEFAULT_INCLUDE_LINE_NUMBERS.\n\n    Raises:\n        Exception: If the input file does not exist.\n\n    Returns:\n        Dict[str, Any]: The record lookup.\n    \"\"\"\n\n    if not os.path.exists(infile):\n        raise Exception(f\"file '{infile}' does not exist\")\n\n    header_to_position_lookup = {}\n    position_to_header_lookup = {}\n    record_list = []\n    record_ctr = 0\n\n    with open(infile) as f:\n        reader = csv.reader(f, delimiter='\\t')\n        for line_num, row in enumerate(reader):\n            if line_num &lt; header_line:\n                logging.info(f\"Will ignore line '{line_num}': {row}\")\n                continue\n            if line_num == header_line:\n                for field_ctr, field in enumerate(row):\n                    header_to_position_lookup[field] = field_ctr\n                    position_to_header_lookup[field_ctr] = field\n                logging.info(f\"Processed the header of tab-delimited file '{infile}'\")\n            elif line_num &gt; header_line:\n                record_lookup = {}\n\n                if include_line_numbers:\n                    record_lookup[\"line_num\"] = line_num\n\n                for field_ctr, value in enumerate(row):\n                    field_name = position_to_header_lookup[field_ctr]\n                    record_lookup[field_name] = value\n                record_list.append(record_lookup)\n                record_ctr += 1\n        logging.info(f\"Processed '{record_ctr}' records in csv file '{infile}'\")\n\n    return record_list\n</code></pre>"},{"location":"tsv2json/#data_file_utils.tsv2json.main","title":"<code>main(config_file, header_line, include_line_numbers, infile, logfile, outdir, outfile, start_line, verbose)</code>","text":"<p>Convert tab-delimited file into JSON file.</p> Source code in <code>data_file_utils/tsv2json.py</code> <pre><code>@click.command()\n@click.option('--config_file', type=click.Path(exists=True), help=f\"Optional: The configuration file for this project - default is '{DEFAULT_CONFIG_FILE}'\")\n@click.option('--header_line', help=f\"Optional: The line number the header row begins - default is '{DEFAULT_HEADER_LINE}'\")\n@click.option('--include_line_numbers', is_flag=True, help=f\"Optional: To include the line numbers in the JSON - default is '{DEFAULT_INCLUDE_LINE_NUMBERS}'\")\n@click.option('--infile', help=\"Required: The primary input file\")\n@click.option('--logfile', help=\"Optional: The log file\")\n@click.option('--outdir', help=f\"Optional: The default is the current working directory - default is '{DEFAULT_OUTDIR}'\")\n@click.option('--outfile', help=\"Optional: The output final report file\")\n@click.option('--start_line', help=f\"Optional: The line number the data rows begin - default is '{DEFAULT_START_LINE}'\")\n@click.option('--verbose', is_flag=True, help=f\"Optional: Will print more info to STDOUT - default is '{DEFAULT_VERBOSE}'.\", callback=validate_verbose)\ndef main(config_file: Optional[str], header_line: Optional[int], include_line_numbers: Optional[bool], infile: str, logfile: Optional[str], outdir: Optional[str], outfile: Optional[str], start_line: Optional[int], verbose: Optional[bool]):\n    \"\"\"Convert tab-delimited file into JSON file.\"\"\"\n\n    error_ctr = 0\n\n    if infile is None:\n        print_red(\"--infile was not specified\")\n        error_ctr += 1\n\n    if error_ctr &gt; 0:\n        click.echo(click.get_current_context().get_help())\n        sys.exit(1)\n\n\n    if config_file is None:\n        config_file = DEFAULT_CONFIG_FILE\n        print_yellow(f\"--config_file was not specified and therefore was set to '{config_file}'\")\n\n    if header_line is None:\n        header_line = DEFAULT_HEADER_LINE\n        print_yellow(f\"--header_line was not specified and therefore was set to '{header_line}'\")\n\n    if include_line_numbers is None:\n        include_line_numbers = DEFAULT_INCLUDE_LINE_NUMBERS\n        print_yellow(f\"--include_line_numbers was not specified and therefore was set to '{include_line_numbers}'\")\n\n    if outdir is None:\n        outdir = DEFAULT_OUTDIR\n        print_yellow(f\"--outdir was not specified and therefore was set to '{outdir}'\")\n\n\n    if not os.path.exists(outdir):\n        pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)\n        print_yellow(f\"Created output directory '{outdir}'\")\n\n    if logfile is None:\n        logfile = os.path.join(\n            outdir,\n            os.path.splitext(os.path.basename(__file__))[0] + '.log'\n        )\n        print_yellow(f\"--logfile was not specified and therefore was set to '{logfile}'\")\n\n    if outfile is None:\n        outfile = os.path.join(\n            outdir,\n            os.path.splitext(os.path.basename(__file__))[0] + '.json'\n        )\n        print_yellow(f\"--outfile was not specified and therefore was set to '{outfile}'\")\n\n    if start_line is None:\n        start_line = DEFAULT_START_LINE\n        print_yellow(f\"--start_line was not specified and therefore was set to '{start_line}'\")\n\n    logging.basicConfig(\n        filename=logfile,\n        format=DEFAULT_LOGGING_FORMAT,\n        level=DEFAULT_LOGGING_LEVEL,\n    )\n\n    check_infile_status(config_file, \"yaml\")\n\n    logging.info(f\"Will load contents of config file '{config_file}'\")\n    config = yaml.safe_load(Path(config_file).read_text())\n\n    convert_file(\n        infile,\n        outfile,\n        start_line=start_line,\n        header_line=header_line,\n        include_line_numbers=include_line_numbers\n    )\n\n    if verbose:\n        console.print(f\"The log file is '{logfile}'\")\n        print_green(f\"Execution of '{os.path.abspath(__file__)}' completed\")\n</code></pre>"},{"location":"tsv2json/#data_file_utils.tsv2json.validate_verbose","title":"<code>validate_verbose(ctx, param, value)</code>","text":"<p>Validate the verbose flag.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The click context.</p> required <code>param</code> <code>str</code> <p>The parameter name.</p> required <code>value</code> <code>bool</code> <p>The value of the parameter.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>The value of the parameter.</p> Source code in <code>data_file_utils/tsv2json.py</code> <pre><code>def validate_verbose(ctx, param, value):\n    \"\"\"Validate the verbose flag.\n\n    Args:\n        ctx (Context): The click context.\n        param (str): The parameter name.\n        value (bool): The value of the parameter.\n\n    Returns:\n        bool: The value of the parameter.\n    \"\"\"\n    if value is None:\n        click.secho(\"--verbose was not specified and therefore was set to 'True'\", fg='yellow')\n        return DEFAULT_VERBOSE\n    return value\n</code></pre>"},{"location":"xlsx2tsv/","title":"Xlsx2Tsv module","text":"<p>Convert Excel file to tab-delimited file.</p>"},{"location":"xlsx2tsv/#data_file_utils.xlsx2tsv.excel_to_tsv","title":"<code>excel_to_tsv(infile, outdir)</code>","text":"<p>Convert the Excel file to a tab-delimited file.</p> <p>Parameters:</p> Name Type Description Default <code>infile</code> <code>str</code> <p>The Excel file to be converted.</p> required <code>outdir</code> <code>str</code> <p>The output directory for the tab-delimited file.</p> required Source code in <code>data_file_utils/xlsx2tsv.py</code> <pre><code>def excel_to_tsv(infile: str, outdir: str) -&gt; None:\n    \"\"\"Convert the Excel file to a tab-delimited file.\n\n    Args:\n        infile (str): The Excel file to be converted.\n        outdir (str): The output directory for the tab-delimited file.\n    \"\"\"\n    # Read the Excel file\n    logging.info(f\"Will convert Excel file '{infile}'\")\n    excel_data = pd.read_excel(infile, sheet_name=None)\n\n    # Iterate over each sheet\n    for sheet_name, sheet_data in excel_data.items():\n        logging.info(f\"Will convert sheet '{sheet_name}'\")\n\n        # Generate the output file name\n        outfile = os.path.join(outdir, f\"{sheet_name.strip().replace(' ', '')}.tsv\")\n\n        # Write the sheet data to a tab-delimited file\n        sheet_data.to_csv(outfile, sep='\\t', index=False)\n\n        print(f\"Sheet '{sheet_name}' has been written to '{outfile}'\")\n        logging.info(f\"Sheet '{sheet_name}' has been written to '{outfile}'\")\n</code></pre>"},{"location":"xlsx2tsv/#data_file_utils.xlsx2tsv.main","title":"<code>main(config_file, infile, logfile, outdir, verbose)</code>","text":"<p>Convert Excel file to tab-delimited file.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Optional[str]</code> <p>The configuration file for this project.</p> required <code>infile</code> <code>str</code> <p>The Excel file to be converted into a tab-delimited file.</p> required <code>logfile</code> <code>Optional[str]</code> <p>The log file.</p> required <code>outdir</code> <code>Optional[str]</code> <p>The output directory.</p> required <code>verbose</code> <code>Optional[bool]</code> <p>Will print more info to STDOUT.</p> required Source code in <code>data_file_utils/xlsx2tsv.py</code> <pre><code>@click.command()\n@click.option('--config_file', type=click.Path(exists=True), help=f\"Optional: The configuration file for this project - default is '{DEFAULT_CONFIG_FILE}'\")\n@click.option('--infile', help=\"Required: The primary input file\")\n@click.option('--logfile', help=\"Optional: The log file\")\n@click.option('--outdir', help=f\"Optional: The default is the current working directory - default is '{DEFAULT_OUTDIR}'\")\n@click.option('--verbose', is_flag=True, help=f\"Will print more info to STDOUT - default is '{DEFAULT_VERBOSE}'.\", callback=validate_verbose)\ndef main(config_file: Optional[str], infile: str, logfile: Optional[str], outdir: Optional[str], verbose: Optional[bool]):\n    \"\"\"Convert Excel file to tab-delimited file.\n\n    Args:\n        config_file (Optional[str]): The configuration file for this project.\n        infile (str): The Excel file to be converted into a tab-delimited file.\n        logfile (Optional[str]): The log file.\n        outdir (Optional[str]): The output directory.\n        verbose (Optional[bool]): Will print more info to STDOUT.\n    \"\"\"\n    error_ctr = 0\n\n    if infile is None:\n        print_red(\"--infile was not specified\")\n        error_ctr += 1\n\n    if error_ctr &gt; 0:\n        click.echo(click.get_current_context().get_help())\n        sys.exit(1)\n\n\n    if config_file is None:\n        config_file = DEFAULT_CONFIG_FILE\n        print_yellow(f\"--config_file was not specified and therefore was set to '{config_file}'\")\n\n    if outdir is None:\n        outdir = DEFAULT_OUTDIR\n        print_yellow(f\"--outdir was not specified and therefore was set to '{outdir}'\")\n\n    if not os.path.exists(outdir):\n        pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)\n        print_yellow(f\"Created output directory '{outdir}'\")\n\n    if logfile is None:\n        logfile = os.path.join(\n            outdir,\n            os.path.splitext(os.path.basename(__file__))[0] + '.log'\n        )\n        print_yellow(f\"--logfile was not specified and therefore was set to '{logfile}'\")\n\n    logging.basicConfig(\n        filename=logfile,\n        format=DEFAULT_LOGGING_FORMAT,\n        level=DEFAULT_LOGGING_LEVEL,\n    )\n\n    check_infile_status(config_file, \"yaml\")\n\n    logging.info(f\"Will load contents of config file '{config_file}'\")\n    config = yaml.safe_load(Path(config_file).read_text())\n\n    excel_to_tsv(infile, outdir)\n\n    if verbose:\n        console.print(f\"The log file is '{logfile}'\")\n        print_green(f\"Execution of '{os.path.abspath(__file__)}' completed\")\n</code></pre>"},{"location":"xlsx2tsv/#data_file_utils.xlsx2tsv.validate_verbose","title":"<code>validate_verbose(ctx, param, value)</code>","text":"<p>Validate the validate option.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The click context.</p> required <code>param</code> <code>str</code> <p>The parameter.</p> required <code>value</code> <code>bool</code> <p>The value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>The value.</p> Source code in <code>data_file_utils/xlsx2tsv.py</code> <pre><code>def validate_verbose(ctx, param, value):\n    \"\"\"Validate the validate option.\n\n    Args:\n        ctx (Context): The click context.\n        param (str): The parameter.\n        value (bool): The value.\n\n    Returns:\n        bool: The value.\n    \"\"\"\n\n    if value is None:\n        click.secho(\"--verbose was not specified and therefore was set to 'True'\", fg='yellow')\n        return DEFAULT_VERBOSE\n    return value\n</code></pre>"}]}